gather(`1999`, `2000`, key="year", value = "populations")
left_join(table4a, table4b)
# One observation might be scattered across multiple rows.
table2
# One observation might be scattered across multiple rows.
table2 %>%
spread(key = type, value = count)
stocks <- tibble(
year   = c(2015, 2015, 2016, 2016),
half  = c(   1,    2,     1,    2),
return = c(1.88, 0.59, 0.92, 0.17)
)
stocks %>%
spread(year, return) %>%
gather("year", "return", `2015`:`2016`)
stocks %>%
spread(year, return)
stocks
people <- tribble(
~name,             ~key,    ~value,
#-----------------|--------|------
"Phillip Woods",   "age",       45,
"Phillip Woods",   "height",   186,
"Phillip Woods",   "age",       50,
"Jessica Cordero", "age",       37,
"Jessica Cordero", "height",   156
)
people %>%
spread("age", "height", value = value)
people <- tribble(
~name,             ~key,    ~value, ~obs,
#-----------------|--------|------|------
"Phillip Woods",   "age",       45, 1,
"Phillip Woods",   "height",   186, 1,
"Phillip Woods",   "age",       50, 2,
"Jessica Cordero", "age",       37, 1,
"Jessica Cordero", "height",   156, 1
)
spread(people, key, value)
people %>%
spread(key, value)
people <- tribble(
~name,             ~key,    ~value,
#-----------------|--------|------
"Phillip Woods",   "age",       45,
"Phillip Woods",   "height",   186,
"Phillip Woods",   "age",       50,
"Jessica Cordero", "age",       37,
"Jessica Cordero", "height",   156
)
people %>%
spread(key, value)
gather(preg, pregnant, count)
preg <- tribble(
~pregnant, ~male, ~female,
"yes",     NA,    10,
"no",      20,    12
)
gather(preg, pregnant, count)
## separate & unite
table3
## separate & unite
table3 %>%
separate(rate, into = c("cases", "population"))
table3 %>%
separate(year, into = c("century", "year"), sep = 2)
table3 %>%
separate(year, into = c("century", "year"), sep = 3)
table3 %>%
separate(year, into = c("century", "year"), sep = 2) # split into first two digits and else
table5
table5 %>%
unite(new, century, year)
table5 %>%
unite(new, century, year, sep = "")
?unite
table5 %>%
unite(new, century, year, sep = "", remove = F)
## Missing values
stocks <- tibble(
year   = c(2015, 2015, 2015, 2015, 2016, 2016, 2016),
qtr    = c(   1,    2,    3,    4,    2,    3,    4),
return = c(1.88, 0.59, 0.35,   NA, 0.92, 0.17, 2.66)
)
stocks %>%
spread(year, return) %>%
gather(year, return, `2015`:`2016`, na.rm = TRUE)
stocks %>%
complete(year, qtr)
treatment <- tribble(
~ person,           ~ treatment, ~response,
"Derrick Whitmore", 1,           7,
NA,                 2,           10,
NA,                 3,           9,
"Katherine Burke",  1,           4
)
treatment %>%
fill()
treatment %>%
fill(person)
head(who)
who1 <- who %>%
gather(new_sp_m014:newrel_f65, key = "key", value = "cases", na.rm = TRUE)
who1
who1 %>%
count(key)
who1
unique(who1$key)
who2 <- who1 %>%
mutate(key = stringr::str_replace("newrel", "new_rel"))
library(stringr)
who2 <- who1 %>%
mutate(key = stringr::str_replace("newrel", "new_rel"))
who2 <- who1 %>%
mutate(key = stringr::str_replace(key, "newrel", "new_rel"))
who2
who3 <- who2 %>%
separate(key, c("new", "type", "sexAge"), sep = "_")
who3
who3 %>%
count(new)
who4 <- who3 %>%
select(-new, -iso3, -iso2) # unselect redundance
who5 <- who4 %>%
separate(sexAge, c("sex", "age"), sep = 1)
who5
eval.n = 100
eval.point = seq(-3,3,length.out = 100)
plot(x,y,pch=20)
idx.mat <- knnx.index(x, eval.point, k=10)
# y_hat(x) = 1/k * sum(index set of xi k-nearest to x * yi)
# KNN is non-parametric regression which means KNN doesn't assume model space
library(FNN)
k10zero <- knnx.index(x, 0, k=10)
x[47]
set.seed(1)
x <- sort(rnorm(100))
y <- 3 + x^2 + rnorm(100)
plot(x, y, pch = 20)
fit = lm(y~x)
str(fit)
coef <- fit$coefficients
coef[1]
coef[2]
abline(coef[1], coef[2], col='red') # model bias ==> evaluated by least square ===> enlarger model space
# y_hat(x) = 1/k * sum(index set of xi k-nearest to x * yi)
# KNN is non-parametric regression which means KNN doesn't assume model space
library(FNN)
k10zero <- knnx.index(x, 0, k=10)
x[47]
x[46]
idx <- k10zero[1,]
points(x[idx], y[idx], pch = 19, col = 'green' )
abline(v=0, lty = 3)
k10mean0 <- mean(y[idx])
abline(h=k10mean0, col = 'blue')
eval.n = 100
eval.point = seq(-3,3,length.out = 100)
plot(x,y,pch=20)
idx.mat <- knnx.index(x, eval.point, k=10)
yhat <- rep(0, eval.n)
for (i in 1:eval.n){
yhat[i] <- mean(y[idx.mat[i,]])
}
lines(eval.point, yhat, type = 'l', col = 'red')
idx.mat
eval.n = 100
eval.point = seq(-3,3,length.out = 100)
plot(x,y,pch=20)
idx.mat <- knnx.index(x, eval.point, k=99)
yhat <- rep(0, eval.n)
for (i in 1:eval.n){
yhat[i] <- mean(y[idx.mat[i,]])
}
lines(eval.point, yhat, type = 'l', col = 'red')
plot(x,y,pch=20)
idx.mat <- knnx.index(x, eval.point, k=90)
yhat <- rep(0, eval.n)
for (i in 1:eval.n){
yhat[i] <- mean(y[idx.mat[i,]])
}
lines(eval.point, yhat, type = 'l', col = 'red')
plot(x,y,pch=20)
idx.mat <- knnx.index(x, eval.point, k=70)
yhat <- rep(0, eval.n)
for (i in 1:eval.n){
yhat[i] <- mean(y[idx.mat[i,]])
}
lines(eval.point, yhat, type = 'l', col = 'red')
plot(x,y,pch=20)
idx.mat <- knnx.index(x, eval.point, k=20)
yhat <- rep(0, eval.n)
for (i in 1:eval.n){
yhat[i] <- mean(y[idx.mat[i,]])
}
lines(eval.point, yhat, type = 'l', col = 'red')
idx.mat <- knnx.index(x, eval.point, k=10)
yhat <- rep(0, eval.n)
for (i in 1:eval.n){
yhat[i] <- mean(y[idx.mat[i,]])
}
lines(eval.point, yhat, type = 'l', col = 'red')
eval.point = seq(-3,3,length.out = 100)
plot(x,y,pch=20)
idx.mat <- knnx.index(x, eval.point, k=10)
yhat <- rep(0, eval.n)
for (i in 1:eval.n){
yhat[i] <- mean(y[idx.mat[i,]])
}
lines(eval.point, yhat, type = 'l', col = 'red')
a = matrix(1:25, 5, 5)
image(a)
a
z <- 2*volcano
dim(z)
x <- 10*(1:nrow(z))
y <- 10*(1:ncol(z))
x
z[30,4]
x[30]
y[4]
persp(x,y,z, theta = 135,
ltheta = 20)
persp(x,y,z, theta = 135,
ltheta = 20, col = "green3")
contour(x,y,z)
state.region
counts <- table(state.region)
counts
barplot(counts, main = "simple bar chart", xlab = "region", ylab = "freq")
sum(counts)
barplot(counts/sum(counts), main = "simple bar chart", xlab = "region", ylab = "freq")
mtcars
mtcars$cyl
barplot(mtcars$cyl, main = "freq of cyl", xlab = "cyl", ylab = "freq")
barplot(as.factor(mtcars$cyl), main = "freq of cyl", xlab = "cyl", ylab = "freq")
barplot(as.factor(mtcars$cyl), main = "freq of cyl", xlab = "cyl", ylab = "freq")
cylt <- table(mtcars$cyl)
barplot(cylt, main = "freq of cyl", xlab = "cyl", ylab = "freq")
cylt
barplot(cylt/sum(cylt), main = "freq of cyl", xlab = "cyl", ylab = "freq")
cyl.name <- c("4 cyl", "6 cyl", "8 cyl")
barplot(cylt/sum(cylt), main = "freq of cyl", xlab = "cyl", ylab = "freq", names.arg = cyl.name)
# pie plot은 좋다고 할 수는 없다
rel.cyl <- cylt/sum(sylt)
# pie plot은 좋다고 할 수는 없다
rel.cyl <- cylt/sum(cylt)
rel.cyl <- round(rel.cylt)
rel.cyl
sum(rel.cyl)
# pie plot은 좋다고 할 수는 없다
(rel.cyl <- cylt/sum(cylt))
pie(rel.cyl)
cyl.name2 <- paste0(names(rel.cyl), " cyl", (,rel.cyl)*100, "%")
cyl.name2 <- paste0(names(rel.cyl), " cyl", (rel.cyl)*100, "%")
pie(rel.cyl, labels = cyl.name2)
cyl.name2 <- paste0(names(rel.cyl), " cyl ", (rel.cyl)*100, "%")
pie(rel.cyl, labels = cyl.name2)
cyl.name2 <- paste0(names(rel.cyl), " cyl (", (rel.cyl)*100, "%)")
pie(rel.cyl, labels = cyl.name2)
cyl.name2 <- paste0(names(rel.cyl), " cyl (", round((rel.cyl)*100), "%)")
pie(rel.cyl, labels = cyl.name2)
cyl.name2 <- paste0(names(rel.cyl), " cyl (", round((rel.cyl)*100, 2), "%)")
pie(rel.cyl, labels = cyl.name2)
library(plotrix)
install.packages("plotrix")
library(plotrix)
# pieplot의 크기 구분 모호함 해결 위해 겹쳐서 표현
fan.plot(rel.cyl, )
# pieplot의 크기 구분 모호함 해결 위해 겹쳐서 표현
fan.plot(rel.cyl, labels=cyl.name2)
install.packages("vcd")
library(vcd)
head(Arthritis, n = 3)
my.table <- xtabs(~ Treatment + Improved, data = Arthritis)
my.table
barplot(my.table, col = c("green", "red"))
barplot(t(my.table), col = c("green", "red"))
barplot(t(my.table), col = c("green", "red", "orange"))
# or
me.table <- xtabs(~ Treatment + Improved, data = Arthritis)
barplot(me.table, col = c("green", "red", "orange"))
# or
me.table <- xtabs(~ Improved+Treatment, data = Arthritis)
barplot(me.table, col = c("green", "red", "orange"))
me.table
me.table$Placebo
me.table[,2]
me.table[,1]
me.table[,1] <- me.table[,1]/sum(me.table[,1])
me.table[,2] <- me.table[,2]/sum(me.table[,2])
me.table
# or
me.table <- xtabs(~ Improved+Treatment, data = Arthritis)
barplot(me.table, col = c("green", "red", "orange"))
# me.table[,1] <- me.table[,1]/sum(me.table[,1])
# me.table[,2] <- me.table[,2]/sum(me.table[,2])
a <- colSums(me.table)
me.table/rep(a, each = 3)
sweep(me.table, 2, a, FUN = "/")
me.table
# 부모님 안전벨트 착용유무와 자녀 착용유무 비교
tmp <- c("buckled", "unbuckled")
belt <- matrix( c(58, 2, 8, 16), ncol = 2,
dimnames = list(parent = tmp, child = tmp))
belt
spine(belt, gp = gpar(fill = c("green", "red")))
# 연속형 자료 요약치 평균, 중앙값, 분위수
x = rnorm(100)
boxplot(x, col = "lightblue")
# 박스플롯으로 안 되고 히스토그램 그려야 하는 경우
x = faithful$waiting
boxplot(x) # bimodal 인지 모르겠
hist(x)
hist(x, nclass = 8) # bimodal 인 걸 알겠다
# 히스토그램을 그리는 방법 중 구간을 나누고 점이 가까우면 데이터로 치는 비중이 높아지고 멀면 비중이 낮아지게 해서 하는 방법을 kernal smoothing이라 한다
hist(x, nclass = 10, probability = T)
lines(density(x), col="red", lwd = 2)
lines(density(x, kernel = 20), col="red", lwd = 2) # kernal smoothing
lines(density(x,bw = 20), col="red", lwd = 2) # kernal smoothing
lines(density(x, bw = 15), col="lightblue", lwd = 2)
install.packages("vioplot")
# violin plot
library(vioplot)
x = rpois(1000, lambda = 3)
vioplot(x, col = "lightblue")
# multi plot
par(mfrow = c(3,1))
hist(mpg[cyl==4], xlab="MPG", main = "MPG dist by cylinder",
xlim = c(5, 40),  ylim = c(0,10), col = 'lightblue',
nclass = trunc(sqrt(length(mpg[cyl==4]))))
hist(mpg[cyl==6], xlab="MPG", main = "MPG dist by cylinder",
xlim = c(5, 40),  ylim = c(0,10), col = 'orange',
nclass = trunc(sqrt(length(mpg[cyl==6]))))
attach(mtcars)
# multi plot
par(mfrow = c(3,1))
hist(mpg[cyl==4], xlab="MPG", main = "MPG dist by cylinder",
xlim = c(5, 40),  ylim = c(0,10), col = 'lightblue',
nclass = trunc(sqrt(length(mpg[cyl==4]))))
hist(mpg[cyl==6], xlab="MPG", main = "MPG dist by cylinder",
xlim = c(5, 40),  ylim = c(0,10), col = 'orange',
nclass = trunc(sqrt(length(mpg[cyl==6]))))
hist(mpg[cyl==8], xlab="MPG", main = "MPG dist by cylinder",
xlim = c(5, 40),  ylim = c(0,10), col = 'red',
nclass = trunc(sqrt(length(mpg[cyl==8]))))
# line으로 겹쳐 그리기
plot(density(mpg[cyl==4]), xlab="MPG", main = "MPG dist by cylinder",
xlim = c(5, 40), ylim = c(0.,0.26))
lines(density(mpg[cyl==6]), col = "red", lty = 2)
lines(density(mpg[cyl==8]), col = "blue", lty = 3)
legend("topright", paste(c(4,6,8), "Cylinder"),
col = c("black","red", "blue"),
lty = c(1,2,3), lwd = 3, bty ="n")
par(mfrow = c(1,1))
# line으로 겹쳐 그리기
plot(density(mpg[cyl==4]), xlab="MPG", main = "MPG dist by cylinder",
xlim = c(5, 40), ylim = c(0.,0.26))
lines(density(mpg[cyl==6]), col = "red", lty = 2)
lines(density(mpg[cyl==8]), col = "blue", lty = 3)
legend("topright", paste(c(4,6,8), "Cylinder"),
col = c("black","red", "blue"),
lty = c(1,2,3), lwd = 3, bty ="n")
### Color
head(colors())
mycol = colors()
plot(1:80, y = rep(1,80), col = mycol[1:80], cex = 2, pch = 20, ylim=c(0,1))
points(1:80, y= rep(0.5, 80), col = mycol[81,160], cex= 2, pch = 20 )
points(1:80, y= rep(0.5, 80), col = mycol[81,160], cex= 2, pch = 20 )
points(1:80, y=rep(0,80), col = mycol[161:240], cex = 2, pch = 20 )
points(1:80, y= rep(0.5, 80), col = mycol[81:160], cex= 2, pch = 20 )
rgb(10, 4, 23, maxColorValue = 255, alpha = 10)
col2rgb('lightblue')
# rgb는 어렵다
hcl(h = 0, c = 35, l = 85, alpha = 0.1)
# 어차피 내가 만드는 건 예쁘기 만들기 어렵다... 만든 palette 쓰자
heat.colors(4, alpha = 1)
rev(heat.colors(4, alpha = 1))
x <- 10*(1:nrow(volcano))
y <- 10*(1:ncol(volcano))
image(x, y, volcano, col = heat.colors(20, alpha = 1), axes = FALSE)
contour(x, y, volcano, levels = seq(90, 200, by = 5),
add = TRUE, col = 'white')
image(x, y, volcano, col = topo.colors(20, alpha = 1), axes = FALSE)
contour(x, y, volcano, levels = seq(90, 200, by = 5),
add = TRUE, col = 'white')
# 거꾸로 하고 싶다면?
image(x, y, volcano, col = rev(heat.colors(20, alpha = 1)), axes = FALSE)
contour(x, y, volcano, levels = seq(90, 200, by = 5),
add = TRUE, col = 'white')
install.packages("RcolorBrewer")
# r에서 제공하는 palett 사용
library(RColorBrewer)
brewer.pal(40, "Blues")
brewer.pal(5, "Blues")
display.brewer.all()
library(colorspace)
pal = choosepal
pal = choose_palette()
VADeaths
barplot(VADeaths, beside = TRUE,col = c("lightblue", "mistyrose", "lightcyan","lavender", "cornsilk"),legend = rownames(VADeaths), ylim = c(0, 100))
title(main = "Death Rates in Virginia", font.main = 4)
#원그래프에 숫자 표시
piepercent<- round(100*pie.sales/sum(pie.sales), 1)
#원그래프
pie.sales <- c(0.12, 0.3, 0.26, 0.16, 0.04, 0.12)
names(pie.sales) <- c("Blueberry", "Cherry","Apple", "Boston Cream", "Other", "Vanilla Cream")
#기본
pie(pie.sales)
title(main = "Sales", font.main = 4)
#원그래프 크기, 방향
pie(pie.sales, radius=1, clockwise=T)
title(main = "Sales", font.main = 4)
#연속형
#히스토그램
data("faithful")
x<-faithful$eruptions
hist(x)
hist(x, breaks=20)
hist(x, breaks=20, freq=FALSE)
#계급구간 길이의 중요
par(mfrow=c(1,2))
edge1<-seq(from=1,to=6,by=0.4)
edge2<-seq(from=1,to=6,by=1)
hist(x,breaks=edge1,freq=F,xlim=c(0,6),ylim=c(0,0.6),main="h=0.4")
hist(x,breaks=edge2,freq=F,xlim=c(0,6),ylim=c(0,0.6),main="h=1")
#줄기-잎 그림
stem(faithful$eruptions)
#산점도
plot(iris$Petal.Length,iris$Petal.Width,xlab='Sepal.Length',
ylab='Sepal.Width',cex.lab=1,cex.axis=1,type='n',cex=2)
points(iris$Petal.Length[iris$Species=='setosa'],
iris$Petal.Width[iris$Species=='setosa'],col='red',lwd=2)
points(iris$Petal.Length[iris$Species=='versicolor'],
iris$Petal.Width[iris$Species=='versicolor'],col='blue',lwd=2)
points(iris$Petal.Length[iris$Species=='virginica'],
iris$Petal.Width[iris$Species=='virginica'],col='green',lwd=2)
#기술통계
#평균 분산
n=length(faithful$eruptions)
sum((faithful$eruptions-mean(faithful$eruptions))^{2})/(n-1)
var(faithful$eruptions)
sqrt(var(faithful$eruptions))
sd(faithful$eruptions)
#분위수
pquant=quantile(faithful$eruptions,probs=c(0.25,0.5,0.75))
pquant
pquant[3]-pquant[1]
IQR(faithful$eruptions)
max(faithful$eruptions)-min(faithful$eruptions)
rfaithful=range(faithful$eruptions)
rfaithful[2]-rfaithful[1]
#outlier detection
iqr.val=IQR(faithful$eruptions)
c(pquant[1]-1.5*iqr.val, pquant[3] +1.5*iqr.val)
faithful$eruptions[faithful$eruptions > pquant[3] +1.5*iqr.val]
faithful$eruptions[faithful$eruptions < pquant[1] -1.5*iqr.val]
summary(faithful$eruptions)
#Boxplot
par(mfrow=c(1,2))
boxplot(faithful$eruptions,main='Eruptions')
boxplot(faithful$waiting,main='Waiting')
#왜도, 첨도
xvec=seq(0.01,0.99,0.01)
par(mfrow=c(1,2))
plot(xvec,dbeta(xvec,2,5),type='l',lwd=2,xlab='',ylab='')
plot(xvec,dbeta(xvec,7,2),type='l',lwd=2,xlab='',ylab='')
x1= rbeta(1000, 2, 5)
x2= rbeta(1000, 7, 2)
(sum((x1-mean(x1))^3)/length(x1))/(var(x1))^{3/2}
(sum((x2-mean(x2))^3)/length(x2))/(var(x2))^{3/2}
par(mfrow=c(1,1))
xvec=seq(-4,4,0.01)
plot(xvec,dnorm(xvec,0,1),type='l',lwd=2,xlab='',ylab='', main="Normal and t-distribution")
lines(xvec,dt(xvec,2),type='l',lwd=2,lty=2, col='red')
x1= rt(1000, 2)
(sum((x1-mean(x1))^4)/length(x1))/(var(x1))^{2} -3
#이변량
x= faithful$eruptions; y= faithful$waiting
cov(x,y)/(sd(x)*sd(y))
cor(x,y)
plot(x,y,xlab='',ylab='')
#원그래프에 숫자 표시
piepercent<- round(100*pie.sales/sum(pie.sales), 1)
piepercent
pie(x=pie.sales, labels=piepercent,col=rainbow(length(pie.sales)))
title(main = "Sales", font.main = 4)
legend('topright', names(pie.sales), cex = 0.7, fill=rainbow(length(pie.sales)))
?var
var(1)
var(1:2)
summary(faithful$eruptions)
apply(faithful, 2, summary)
faithful
summary(faithful$eruptions)
apply(faithful, 2, summary)
#Boxplot
par(mfrow=c(1,2))
boxplot(faithful$eruptions,main='Eruptions')
boxplot(faithful$waiting,main='Waiting')
#Boxplot
par(mfrow=c(1,1))
#왜도, 첨도
xvec=seq(0.01,0.99,0.01)
par(mfrow=c(1,2))
plot(xvec,dbeta(xvec,2,5),type='l',lwd=2,xlab='',ylab='')
plot(xvec,dbeta(xvec,7,2),type='l',lwd=2,xlab='',ylab='')
#이변량
x= faithful$eruptions; y= faithful$waiting
cov(x,y)/(sd(x)*sd(y))
cor(x,y)
plot(x,y,xlab='',ylab='')
