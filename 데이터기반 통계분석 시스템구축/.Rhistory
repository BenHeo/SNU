cyl.name2 <- paste0(names(rel.cyl), " cyl ", (rel.cyl)*100, "%")
pie(rel.cyl, labels = cyl.name2)
cyl.name2 <- paste0(names(rel.cyl), " cyl (", (rel.cyl)*100, "%)")
pie(rel.cyl, labels = cyl.name2)
cyl.name2 <- paste0(names(rel.cyl), " cyl (", round((rel.cyl)*100), "%)")
pie(rel.cyl, labels = cyl.name2)
cyl.name2 <- paste0(names(rel.cyl), " cyl (", round((rel.cyl)*100, 2), "%)")
pie(rel.cyl, labels = cyl.name2)
library(plotrix)
install.packages("plotrix")
library(plotrix)
# pieplot의 크기 구분 모호함 해결 위해 겹쳐서 표현
fan.plot(rel.cyl, )
# pieplot의 크기 구분 모호함 해결 위해 겹쳐서 표현
fan.plot(rel.cyl, labels=cyl.name2)
install.packages("vcd")
library(vcd)
head(Arthritis, n = 3)
my.table <- xtabs(~ Treatment + Improved, data = Arthritis)
my.table
barplot(my.table, col = c("green", "red"))
barplot(t(my.table), col = c("green", "red"))
barplot(t(my.table), col = c("green", "red", "orange"))
# or
me.table <- xtabs(~ Treatment + Improved, data = Arthritis)
barplot(me.table, col = c("green", "red", "orange"))
# or
me.table <- xtabs(~ Improved+Treatment, data = Arthritis)
barplot(me.table, col = c("green", "red", "orange"))
me.table
me.table$Placebo
me.table[,2]
me.table[,1]
me.table[,1] <- me.table[,1]/sum(me.table[,1])
me.table[,2] <- me.table[,2]/sum(me.table[,2])
me.table
# or
me.table <- xtabs(~ Improved+Treatment, data = Arthritis)
barplot(me.table, col = c("green", "red", "orange"))
# me.table[,1] <- me.table[,1]/sum(me.table[,1])
# me.table[,2] <- me.table[,2]/sum(me.table[,2])
a <- colSums(me.table)
me.table/rep(a, each = 3)
sweep(me.table, 2, a, FUN = "/")
me.table
# 부모님 안전벨트 착용유무와 자녀 착용유무 비교
tmp <- c("buckled", "unbuckled")
belt <- matrix( c(58, 2, 8, 16), ncol = 2,
dimnames = list(parent = tmp, child = tmp))
belt
spine(belt, gp = gpar(fill = c("green", "red")))
# 연속형 자료 요약치 평균, 중앙값, 분위수
x = rnorm(100)
boxplot(x, col = "lightblue")
# 박스플롯으로 안 되고 히스토그램 그려야 하는 경우
x = faithful$waiting
boxplot(x) # bimodal 인지 모르겠
hist(x)
hist(x, nclass = 8) # bimodal 인 걸 알겠다
# 히스토그램을 그리는 방법 중 구간을 나누고 점이 가까우면 데이터로 치는 비중이 높아지고 멀면 비중이 낮아지게 해서 하는 방법을 kernal smoothing이라 한다
hist(x, nclass = 10, probability = T)
lines(density(x), col="red", lwd = 2)
lines(density(x, kernel = 20), col="red", lwd = 2) # kernal smoothing
lines(density(x,bw = 20), col="red", lwd = 2) # kernal smoothing
lines(density(x, bw = 15), col="lightblue", lwd = 2)
install.packages("vioplot")
# violin plot
library(vioplot)
x = rpois(1000, lambda = 3)
vioplot(x, col = "lightblue")
# multi plot
par(mfrow = c(3,1))
hist(mpg[cyl==4], xlab="MPG", main = "MPG dist by cylinder",
xlim = c(5, 40),  ylim = c(0,10), col = 'lightblue',
nclass = trunc(sqrt(length(mpg[cyl==4]))))
hist(mpg[cyl==6], xlab="MPG", main = "MPG dist by cylinder",
xlim = c(5, 40),  ylim = c(0,10), col = 'orange',
nclass = trunc(sqrt(length(mpg[cyl==6]))))
attach(mtcars)
# multi plot
par(mfrow = c(3,1))
hist(mpg[cyl==4], xlab="MPG", main = "MPG dist by cylinder",
xlim = c(5, 40),  ylim = c(0,10), col = 'lightblue',
nclass = trunc(sqrt(length(mpg[cyl==4]))))
hist(mpg[cyl==6], xlab="MPG", main = "MPG dist by cylinder",
xlim = c(5, 40),  ylim = c(0,10), col = 'orange',
nclass = trunc(sqrt(length(mpg[cyl==6]))))
hist(mpg[cyl==8], xlab="MPG", main = "MPG dist by cylinder",
xlim = c(5, 40),  ylim = c(0,10), col = 'red',
nclass = trunc(sqrt(length(mpg[cyl==8]))))
# line으로 겹쳐 그리기
plot(density(mpg[cyl==4]), xlab="MPG", main = "MPG dist by cylinder",
xlim = c(5, 40), ylim = c(0.,0.26))
lines(density(mpg[cyl==6]), col = "red", lty = 2)
lines(density(mpg[cyl==8]), col = "blue", lty = 3)
legend("topright", paste(c(4,6,8), "Cylinder"),
col = c("black","red", "blue"),
lty = c(1,2,3), lwd = 3, bty ="n")
par(mfrow = c(1,1))
# line으로 겹쳐 그리기
plot(density(mpg[cyl==4]), xlab="MPG", main = "MPG dist by cylinder",
xlim = c(5, 40), ylim = c(0.,0.26))
lines(density(mpg[cyl==6]), col = "red", lty = 2)
lines(density(mpg[cyl==8]), col = "blue", lty = 3)
legend("topright", paste(c(4,6,8), "Cylinder"),
col = c("black","red", "blue"),
lty = c(1,2,3), lwd = 3, bty ="n")
### Color
head(colors())
mycol = colors()
plot(1:80, y = rep(1,80), col = mycol[1:80], cex = 2, pch = 20, ylim=c(0,1))
points(1:80, y= rep(0.5, 80), col = mycol[81,160], cex= 2, pch = 20 )
points(1:80, y= rep(0.5, 80), col = mycol[81,160], cex= 2, pch = 20 )
points(1:80, y=rep(0,80), col = mycol[161:240], cex = 2, pch = 20 )
points(1:80, y= rep(0.5, 80), col = mycol[81:160], cex= 2, pch = 20 )
rgb(10, 4, 23, maxColorValue = 255, alpha = 10)
col2rgb('lightblue')
# rgb는 어렵다
hcl(h = 0, c = 35, l = 85, alpha = 0.1)
# 어차피 내가 만드는 건 예쁘기 만들기 어렵다... 만든 palette 쓰자
heat.colors(4, alpha = 1)
rev(heat.colors(4, alpha = 1))
x <- 10*(1:nrow(volcano))
y <- 10*(1:ncol(volcano))
image(x, y, volcano, col = heat.colors(20, alpha = 1), axes = FALSE)
contour(x, y, volcano, levels = seq(90, 200, by = 5),
add = TRUE, col = 'white')
image(x, y, volcano, col = topo.colors(20, alpha = 1), axes = FALSE)
contour(x, y, volcano, levels = seq(90, 200, by = 5),
add = TRUE, col = 'white')
# 거꾸로 하고 싶다면?
image(x, y, volcano, col = rev(heat.colors(20, alpha = 1)), axes = FALSE)
contour(x, y, volcano, levels = seq(90, 200, by = 5),
add = TRUE, col = 'white')
install.packages("RcolorBrewer")
# r에서 제공하는 palett 사용
library(RColorBrewer)
brewer.pal(40, "Blues")
brewer.pal(5, "Blues")
display.brewer.all()
library(colorspace)
pal = choosepal
pal = choose_palette()
VADeaths
barplot(VADeaths, beside = TRUE,col = c("lightblue", "mistyrose", "lightcyan","lavender", "cornsilk"),legend = rownames(VADeaths), ylim = c(0, 100))
title(main = "Death Rates in Virginia", font.main = 4)
#원그래프에 숫자 표시
piepercent<- round(100*pie.sales/sum(pie.sales), 1)
#원그래프
pie.sales <- c(0.12, 0.3, 0.26, 0.16, 0.04, 0.12)
names(pie.sales) <- c("Blueberry", "Cherry","Apple", "Boston Cream", "Other", "Vanilla Cream")
#기본
pie(pie.sales)
title(main = "Sales", font.main = 4)
#원그래프 크기, 방향
pie(pie.sales, radius=1, clockwise=T)
title(main = "Sales", font.main = 4)
#연속형
#히스토그램
data("faithful")
x<-faithful$eruptions
hist(x)
hist(x, breaks=20)
hist(x, breaks=20, freq=FALSE)
#계급구간 길이의 중요
par(mfrow=c(1,2))
edge1<-seq(from=1,to=6,by=0.4)
edge2<-seq(from=1,to=6,by=1)
hist(x,breaks=edge1,freq=F,xlim=c(0,6),ylim=c(0,0.6),main="h=0.4")
hist(x,breaks=edge2,freq=F,xlim=c(0,6),ylim=c(0,0.6),main="h=1")
#줄기-잎 그림
stem(faithful$eruptions)
#산점도
plot(iris$Petal.Length,iris$Petal.Width,xlab='Sepal.Length',
ylab='Sepal.Width',cex.lab=1,cex.axis=1,type='n',cex=2)
points(iris$Petal.Length[iris$Species=='setosa'],
iris$Petal.Width[iris$Species=='setosa'],col='red',lwd=2)
points(iris$Petal.Length[iris$Species=='versicolor'],
iris$Petal.Width[iris$Species=='versicolor'],col='blue',lwd=2)
points(iris$Petal.Length[iris$Species=='virginica'],
iris$Petal.Width[iris$Species=='virginica'],col='green',lwd=2)
#기술통계
#평균 분산
n=length(faithful$eruptions)
sum((faithful$eruptions-mean(faithful$eruptions))^{2})/(n-1)
var(faithful$eruptions)
sqrt(var(faithful$eruptions))
sd(faithful$eruptions)
#분위수
pquant=quantile(faithful$eruptions,probs=c(0.25,0.5,0.75))
pquant
pquant[3]-pquant[1]
IQR(faithful$eruptions)
max(faithful$eruptions)-min(faithful$eruptions)
rfaithful=range(faithful$eruptions)
rfaithful[2]-rfaithful[1]
#outlier detection
iqr.val=IQR(faithful$eruptions)
c(pquant[1]-1.5*iqr.val, pquant[3] +1.5*iqr.val)
faithful$eruptions[faithful$eruptions > pquant[3] +1.5*iqr.val]
faithful$eruptions[faithful$eruptions < pquant[1] -1.5*iqr.val]
summary(faithful$eruptions)
#Boxplot
par(mfrow=c(1,2))
boxplot(faithful$eruptions,main='Eruptions')
boxplot(faithful$waiting,main='Waiting')
#왜도, 첨도
xvec=seq(0.01,0.99,0.01)
par(mfrow=c(1,2))
plot(xvec,dbeta(xvec,2,5),type='l',lwd=2,xlab='',ylab='')
plot(xvec,dbeta(xvec,7,2),type='l',lwd=2,xlab='',ylab='')
x1= rbeta(1000, 2, 5)
x2= rbeta(1000, 7, 2)
(sum((x1-mean(x1))^3)/length(x1))/(var(x1))^{3/2}
(sum((x2-mean(x2))^3)/length(x2))/(var(x2))^{3/2}
par(mfrow=c(1,1))
xvec=seq(-4,4,0.01)
plot(xvec,dnorm(xvec,0,1),type='l',lwd=2,xlab='',ylab='', main="Normal and t-distribution")
lines(xvec,dt(xvec,2),type='l',lwd=2,lty=2, col='red')
x1= rt(1000, 2)
(sum((x1-mean(x1))^4)/length(x1))/(var(x1))^{2} -3
#이변량
x= faithful$eruptions; y= faithful$waiting
cov(x,y)/(sd(x)*sd(y))
cor(x,y)
plot(x,y,xlab='',ylab='')
#원그래프에 숫자 표시
piepercent<- round(100*pie.sales/sum(pie.sales), 1)
piepercent
pie(x=pie.sales, labels=piepercent,col=rainbow(length(pie.sales)))
title(main = "Sales", font.main = 4)
legend('topright', names(pie.sales), cex = 0.7, fill=rainbow(length(pie.sales)))
?var
var(1)
var(1:2)
summary(faithful$eruptions)
apply(faithful, 2, summary)
faithful
summary(faithful$eruptions)
apply(faithful, 2, summary)
#Boxplot
par(mfrow=c(1,2))
boxplot(faithful$eruptions,main='Eruptions')
boxplot(faithful$waiting,main='Waiting')
#Boxplot
par(mfrow=c(1,1))
#왜도, 첨도
xvec=seq(0.01,0.99,0.01)
par(mfrow=c(1,2))
plot(xvec,dbeta(xvec,2,5),type='l',lwd=2,xlab='',ylab='')
plot(xvec,dbeta(xvec,7,2),type='l',lwd=2,xlab='',ylab='')
#이변량
x= faithful$eruptions; y= faithful$waiting
cov(x,y)/(sd(x)*sd(y))
cor(x,y)
plot(x,y,xlab='',ylab='')
volcano
?image
library(dplyr)
# library(dplyr)
library(tidyverse)
list.files()
# list.files()
list.files("data")
# list.files()
list.files("data")
surveys <- fread("data/surveys.csv")
surveys <- read_csv("data/surveys.csv")
source('C:/Users/renz/Desktop/SNU/데이터기반 통계분석 시스템구축/DataProcessing.R', echo=TRUE)
surveys <- read.csv("data/surveys.csv")
names(surveys)
surveys[, match(c("plot_id", "species_id", "weight"),  names(surveys)) ]
# 사실 df는 그냥 열 이름 넣으면 된다
surveys[,c("plot_id", "species_id", "weight")]
# df는 df이기 이전에 list이기 때문에 체인을 직접 불러오는 방법 가능하다
surveys[c("plot_id", "species_id", "weight")]
# year가 1995인 데이터 행만 추출
head(surveys[surveys$year == 1995,])
# year가 1995인 데이터 행만 추출
head(surveys[surveys$year == 1995])
# year가 1995인 데이터 행만 추출
head(surveys[surveys$year == 1995,])
surveys[surveys$weight<5, c("plot_id", "species_id", "weight")]
surveys[which(surveys$weight<5), c("plot_id", "species_id", "weight")]
# weight를 kg으로 하는 col 만들기
surveys_ex <- surveys # 원본 손상 x 위해서
surveys_ex$weight_kg <- surveys_ex$weight/1000
surveys_ex <- surveys_ex[!is.na(surveys_ex$weight_kg),] # na는 제
# sex로 group 하기
u = unique(surveys$sex)
length(u)
u
class(U); levels(u)
class(u); levels(u)
#sex별로 weight계산
mean(surveys$weight[surveys$sex == u[1]], na.rm = T)
mean(surveys$weight[surveys$sex == u[2]], na.rm = T)
mean(surveys$weight[surveys$sex == u[3]], na.rm = T)
sum(!is.na(surveys$weight[surveys$sex == u[1]]))
nrow(surveys)
sum(!is.na(surveys$weight[surveys$sex == u[2]]))
sum(!is.na(surveys$weight[surveys$sex == u[3]]))
sum(!is.na(surveys$weight[surveys$sex == u[1]]))
# sum(!is.na(surveys$weight[surveys$sex == u[1]])) # 몸무게가 na인 사람들을 제외한 사람의 수
# by 로 group
by(data = surveys$weight, INDICES = surveys$sex, FUN = mean, na.rm = TRUE)
# sum(!is.na(surveys$weight[surveys$sex == u[1]])) # 몸무게가 na인 사람들을 제외한 사람의 수
# by 로 group
a <- by(data = surveys$weight, INDICES = surveys$sex, FUN = mean, na.rm = TRUE)
unlist(a)
unlist(a)[3]
# by에 INDICES 일일이 써주는 건 귀찮다
aggregate(formula = weight ~ sex, data = surveys, FUN = mean, na.rm = TRUE)
aggregate(formula = weight ~ sex+species_id, data = surveys, FUN = mean, na.rm = TRUE)
# 표준편차 구하기
aggregate(formula = weight ~ sex+species_id, data = surveys, FUN = sd, na.rm = TRUE)
# aggregate 는 FUN을 하나만 하니까 여러 정보량을 동시에 구하기에 적합하지 않다
a = c(10, 5, 3, 7)
order(a)
a[order(a)]]
a[order(a)]
a[order(a, decreasing = TRUE)]
# aggregate 는 FUN을 하나만 하니까 여러 정보량을 동시에 구하기에 적합하지 않다
table(surveys$sex, surveys$plot_id)
# plot_id 오름차순으로 surveys 정렬
surveys[order(surveys$plot_id),]
#####################################################################################################################
# dplyr
surveys %>%
select(plot_id, species_id, weight) %>%
n(10)
#####################################################################################################################
# dplyr
surveys %>%
select(plot_id, species_id, weight) %>%
n() == 10
#####################################################################################################################
# dplyr
surveys %>%
select(plot_id, species_id, weight) %>%
n() = 1
#####################################################################################################################
# dplyr
surveys %>%
select(plot_id, species_id, weight) %>%
n = 10
source('C:/Users/renz/Desktop/SNU/데이터기반 통계분석 시스템구축/DataProcessing.R', encoding = 'UTF-8', echo=TRUE)
surveys %>%
filter(year == 1995, weight > 20)
surveys %>%
filter(year == 1995, weight > 30)
surveys %>%
filter(year == 1995, weight > 40)
surveys %>%
filter(year == 1995, weight > 50)
surveys %>%
filter(year == 1995, weight > 60)
surveys %>%
filter(!is.na(weight)) %>%
filter(weight < 5) %>%
select(species_id, sex, weight) %>% head()
surveys_ex <- surveys %>%
filter(!is.na(weight)) %>%
mutate(weight_kg = weight/1000)
surveys %>%
group_by(sex) %>%
summarize(mean_weight = mean(weight, na.rm = TRUE))
# summarize를 이용하면 여러 function을 한번에 쓸 수 있다
surveys %>%
filter(!is.na(weight)) %>%
group_by(sex, species_id) %>%
summarize(mean_weight = mean(weight),
var_weight = var(weight),
min_weight = min(weight),
max_weight = max(weight)) %>%
print(n = 5)
# 갯수 세기
surveys %>%
group_by(sex) %>%
tally()
# 정렬하기
surveys %>%
arrange(month, plot_id) %>%
head()
## 내림차순은 앞에 desc 붙이기
surveys %>%
arrange(desc(month), plot_id) %>%
head()
################################################################################################################
# reshape2
library(reshape2)
# wide format & long format
# 함수에 따라 wide를 요구하기도 하고 long 을 요구하기도 한다
names(airquality)
# wide format & long format
# 함수에 따라 wide를 요구하기도 하고 long 을 요구하기도 한다
names(airquality) <- tolower(names(airquality))
melt(airquality) %>%
head(3)
head(airquality)
melt(airquality) %>%
head(300)
melt(airquality) %>%
head(3)
aql <- melt(data = airquality, id.vars= c("month","day"))
head(aql, n = 3)
aql <- melt(data = airquality, id.vars= c("month","day"),
variable.name = "climate_variable",
value.name = "climate_value") # month와 day를 기준으로 melt한다
head(aql, n = 3)
# dcast는 long format을 wide format으로
dcast(aql, month~climate_variable, fun.aggregate = mean, na.rm=TRUE, margins = TRUE) %<%
head()
# dcast는 long format을 wide format으로
dcast(aql, month~climate_variable, fun.aggregate = mean, na.rm=TRUE, margins = TRUE) %>%
head()
paste("감자로","만든","감자칩", sep='-')
paste0(1:12, c("st", "nd", "rd", rep("th", 9)))
paste0(1:12, collapse = "-")
paste(1:4,5:8, sep = ';')
paste(1:4,5:8, sep = ';', collapse = '-')
source('C:/Users/renz/Desktop/SNU/데이터기반 통계분석 시스템구축/TextFunction.R', encoding = 'UTF-8', echo=TRUE)
# grep 함수 # 문자열에 패턴(단어)가 포함되어 있는지를 확인하는 함수임. 패턴이 포함되어 있는 위치 반환
grep('a', 'bbbb')
grep('a', 'bbabb')
grep("pole", c("Equator", "North Pole", "South pole", "poles"))
# nchar # 문자열의 단어 개수를 계산
nchar(c("South Pole", "한글 문자열", NA))
# substr 함수 # start부터 stop라(include)까지 문자 가져와라
substr("Equator", start = 2, stop = 4)
substr("한글 문자열 추출", start = 2, stop = 4)
substring("한글 문자열 추출", first = 2)
strsplit("6-16-2011", split = "-")
strsplit(c("6-16-2011", "1-1-1-2-1-1"), split = "-")
# 특수문자 이용한 분리
strsplit("6*16*2011", split = '*')
strsplit("6*16*2011", split = '\\*')
strsplit("6*16*2011", split = '*', fixed = TRUE) # 같은 기
#### 많이 쓰는 이스케이프 문자  '\t': 탭, '\n':줄바꿈문자. '\d':숫자
list.files()
strsplit(list.files(), split = '.', fixed = T)
a = strsplit(list.files(), split = '.', fixed = T) # 파일명과 확장자가 분리되었다
a[[1]]
for (i in 1:length(a))
{
b = a[[i]]
if (length(b) == 2)
{
print(b[-1])
}
}
tmp = rep(0, length(a))
tmp
tmp = rep(0, length(a))
for (i in 1:length(a))
{
b = a[[i]]
if (length(b) == 2)
{
tmp[i] = b[-1]
}
}
table(tmp)
regexpr("감자", "맛있는 감자칩")
gsub(pattern = "감자", replacement='고구마',
x= "머리를 감자마자 감자칩을 먹었다.")
###########################################
# 정규표현식
## OR
strsplit('감자, 고구마, 양파 그리고 파이어볼', split = '(,)|(그리고)')
###########################################
# 정규표현식
## OR
strsplit('감자, 고구마, 양파 그리고 파이어볼', split = '(, )|( 그리고 )')
## 시작
grep(pattern = '^(감자)', x = '감자는 고구마를 좋아해')
grep(pattern = '^(감자)', x = '고구마는 감자를 좋아해')
grep(pattern = '^(감자)', x = '고구마는 감자를 좋아해') # 해당 패턴이 없어서 integer(0)
## 끝 : $
grep(pattern = '(좋아해)$', x = '감자는 고구마를 좋아해')
## ANY : []
gregexpr(pattern = '[아자차카]', text = '고구마는 감자를 안 좋아해')
gregexpr(pattern = '[(사과)(감자)(양파)]', text = '고구마는 감자를 안 좋아해')
## 반복 : {}   {from,to} 를 이용하여 생성. 바로 앞 문자에 대한 패턴임을 주의! o{2,4} 는 문자 o가 2번에서 4번까지 반복되는 패턴
#             [a-z]{3,6} 영어 소문자가 3번에서 6번까지 반복되는 패턴 {5} 는 5번 {5,} 5번 이상 반복을 뜻함.
grep(pattern = '^ab{2,3}', x = 'ab')
gregexpr(pattern = '[(사과)(감자)(양파)]', text = '고구마는 감자를 안 좋아해')
gregexpr(pattern = '[(사과)(감자)(양파)]', text = '고구마는 감자를 안 좋아해')
gregexpr(pattern = '[(사과)(감자나)(양파)]', text = '고구마는 감자를 안 좋아해')
gregexpr(pattern = '[(사과)(감자)(양파)]', text = '고구마는 감자를 안 좋아해')
gregexpr(pattern = '[(사과)(감)(양파)]', text = '고구마는 감자를 안 좋아해')
gregexpr(pattern = '[(사과)(감자)(양파)]', text = '고구마는 감자를 안 좋아해')
## everything except : [^]
grep(pattern = '^[^(사과)(감자)(양파)]', x = '감자는 고구마를 좋아해') # ^는 시작함을 의미 [^]에서 사과,감자,양파로 시작 안 하는 것을 요구
## everything except : [^]
grep(pattern = '^[^(사과)(감자)(양파)]', x = '감자는 고구마를 좋아해') # ^는 시작함을 의미 [^]에서 사과,감자,양파로 시작 안 하는 것을 요구
## everything except : [^]
grep(pattern = '^[^(사과)(감자나)(양파)]', x = '감자는 고구마를 좋아해') # ^는 시작함을 의미 [^]에서 사과,감자,양파로 시작 안 하는 것을 요구
## everything except : [^]
grep(pattern = '^[^(사과)(감자)(양파)]', x = '감자는 고구마를 좋아해') # ^는 시작함을 의미 [^]에서 사과,감자,양파로 시작 안 하는 것을 요구
grep()
grep('[a-z]', x='abra')
grep('^[a-z]', x='abra')
grep('^[a-z]', x='Abra')
grep('^[a-z]', x='0Abra')
grep('[^a-z]', x='0Abra')
# *: {0,}
# +: {1,}
# ?: {0,1}
# .: 어떠한 문자라도 1개
grep(pattern = '^a+', x = 'ab')
grep(pattern = '^a*', x = 'ab')
