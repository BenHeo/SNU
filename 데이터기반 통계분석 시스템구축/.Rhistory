url = paste0("https://movie.naver.com/movie/point/af/list.nhn?&page=",i)
mov_html = read_html(GET(url), encoding = "CP949")
content = html_nodes(mov_html, '.title') %>% html_text()
content = gsub('\n|\t|<.*?>|&quot;','',content)
point = html_nodes(mov_html, '.point') %>% html_text()
part_star = data.frame(do.call(rbind,
lapply(strsplit(content, "\r"), function(x) {x[x != "" & x != "신고"]})), point = point)
total_star = rbind(total_star, part_star)
cat(i, "\n")
}
head(total_star)
# 네이버 영화 평점
### gsub는 매칭되는 것 다 찾아서 원하는 것으로 바꿈
## 평가 글 크롤링
total_con = NULL
for (i in 1:10) {
movie_url = paste0('https://movie.naver.com/movie/point/af/list.nhn?&page=', i)
movie_html = read_html(GET(movie_url), encoding = 'UTF-8')
contents = html_nodes(movie_html, '.title') %>%
html_text() # 이대로 출력하면 \r\n\t 같은 것이 매우 많다
contents = gsub('\n|\t|<.*?>|&quot;', '', contents) # \n \t <br> "" '' 같이 표현된 모든 것을 제거
# 이렇게 하면 \r 이랑 신고 외에는 대부분 정상적이다
part_con = data.frame(do.call(rbind,
lapply(strsplit(contents, '\r'), # \r 로 split한다
function(x) {x[x != "" & x != "신고"]} ))) # 빈 것과 신고는 지운다
total_con = rbind(total_con, part_con)
cat(i, "\n")
}
# 네이버 영화 평점
### gsub는 매칭되는 것 다 찾아서 원하는 것으로 바꿈
## 평가 글 크롤링
total_con = NULL
for (i in 1:10) {
movie_url = paste0('https://movie.naver.com/movie/point/af/list.nhn?&page=', i)
movie_html = read_html(GET(movie_url), encoding = 'CP949')
contents = html_nodes(movie_html, '.title') %>%
html_text() # 이대로 출력하면 \r\n\t 같은 것이 매우 많다
contents = gsub('\n|\t|<.*?>|&quot;', '', contents) # \n \t <br> "" '' 같이 표현된 모든 것을 제거
# 이렇게 하면 \r 이랑 신고 외에는 대부분 정상적이다
part_con = data.frame(do.call(rbind, # do.call은 list에 있는 내용에 대해 특정 function을 수행해주는 것
lapply(strsplit(contents, '\r'), # \r 로 split한다
function(x) {x[x != "" & x != "신고"]} ))) # 빈 것과 신고는 지운다
total_con = rbind(total_con, part_con)
cat(i, "\n")
}
## 글 + 평점 크롤링
total_star = NULL
for(i in 1:10){
url = paste0("https://movie.naver.com/movie/point/af/list.nhn?&page=",i)
mov_html = read_html(GET(url), encoding = "CP949")
content = html_nodes(mov_html, '.title') %>% html_text()
content = gsub('\n|\t|<.*?>|&quot;','',content)
point = html_nodes(mov_html, '.point') %>% html_text()
part_star = data.frame(do.call(rbind,
lapply(strsplit(content, "\r"), function(x) {x[x != "" & x != "신고"]})), point = point)
total_star = rbind(total_star, part_star)
cat(i, "\n")
}
head(total_star)
pnorm(2)
_-5
pnorm(2)-0.5
(pnorm(2)-0.5)*2
?graph.adjacency
??graph.adjacency
?igraph::simplify
?igraph::cluster_walktrap
?igraph::membership
members
source('C:/Users/renz/Desktop/SNU/데이터기반 통계분석 시스템구축/Network.R', encoding = 'UTF-8', echo=TRUE)
getwd()
setwd('C:\Users\renz\Desktop\SNU\데이터기반 통계분석 시스템구축')
setwd('C:/Users/renz/Desktop/SNU/데이터기반 통계분석 시스템구축')
source('C:/Users/renz/Desktop/SNU/데이터기반 통계분석 시스템구축/Network.R', encoding = 'UTF-8', echo=TRUE)
?igraph::cluster_fast_greedy
network_list = cluster_fast_greedy(g)
network_list$links$group = network_list$nodes$group[network_list$links$source+1]
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
NodeGroup = "group", LinkGroup = "group",
units = "TWh", fontSize = 18, nodeWidth = 30)
network_list = cluster_fast_greedy(g, group = members)
head(network_list)
g = graph.adjacency(co_occur_mat1, weighted = T, mode = 'undirected') # 인접행렬 형태에서 igraph 만들기 편하게 해주는 함수
g = simplify(g) # loop나 다중간선 없게
head(g)
wc = cluster_walktrap(g) # communities(densely connected subgraphs) 찾기
members = membership(wc)
head(wc)
head(members)
network_list = cluster_fast_greedy(g, members)
network_list$links$group = network_list$nodes$group[network_list$links$source+1]
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
NodeGroup = "group", LinkGroup = "group",
units = "TWh", fontSize = 18, nodeWidth = 30)
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
NodeGroup = "group", LinkGroup = "group",
units = "TWh", fontSize = 18, nodeWidth = 30)
# 연결관계끼리 관계선을 연결성 느껴지게 그리기. 선후 관계가 없는 관계인데 그냥 먼저 나오는 것의 색을 유지
network_list = igraph_to_networkD3(g, group = as.character(members))
network_list$links$group = network_list$nodes$group[network_list$links$source+1]
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
NodeGroup = "group", LinkGroup = "group",
units = "TWh", fontSize = 18, nodeWidth = 30)
network_list = igraph_to_networkD3(cluster_fast_greedy(g))
network_list$links$group = network_list$nodes$group[network_list$links$source+1]
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
NodeGroup = "group", LinkGroup = "group",
units = "TWh", fontSize = 18, nodeWidth = 30)
# 연결관계끼리 관계선을 연결성 느껴지게 그리기. 선후 관계가 없는 관계인데 그냥 먼저 나오는 것의 색을 유지
network_list = igraph_to_networkD3(g, group = as.character(members))
network_list$links$group = network_list$nodes$group[network_list$links$source+1]
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
NodeGroup = "group", LinkGroup = "group",
units = "TWh", fontSize = 18, nodeWidth = 30)
class(g)
g = graph.adjacency(co_occur_mat1, weighted = T, mode = 'undirected') # 인접행렬 형태에서 igraph 만들기 편하게 해주는 함수
g = simplify(g) # loop나 다중간선 없게
class(g)
class(network_list)
g = graph.adjacency(co_occur_mat1, weighted = T, mode = 'undirected') # 인접행렬 형태에서 igraph 만들기 편하게 해주는 함수
g = simplify(g) # loop나 다중간선 없게
wc = cluster_walktrap(g) # communities(densely connected subgraphs) 찾기
members = membership(wc)
network_list = igraph_to_networkD3(g, group = members) # igraph to d3 list
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
units = "TWh", fontSize = 18, nodeWidth = 30)
# circular plot
if(!require(circlize)){install.packages("circlize"); library(circlize)}
name=c(3,10,10,3,6,7,8,3,6,1,2,2,6,10,2,3,3,10,4,5,9,10)
feature=paste("feature ", c(1,1,2,2,2,2,2,3,3,3,3,3,3,3,4,4,4,4,5,5,5,5),
sep="")
dat <- data.frame(name,feature)
head(dat)
dat <- data.frame(name,feature)
dat <- table(name, feature)
head(dat,4)
chordDiagram(as.data.frame(dat), transparency = 0.5)
class(dat)
typeof(dat)
library(chorddiag)}
if(!require(RColorBrewer)){install.packages("RColorBrewer")}
if(!require(chorddiag)){devtools::install_github("mattflor/chorddiag"); # should install devtools package
library(chorddiag)}
doc_list = data_list$n_gram
table_list = lapply(doc_list, table)[1:3]
table_name = unique(unlist(do.call("c", doc_list[1:3] )))
names(table_list) = paste0("doc_", 1:3)
table_list = lapply(table_list, function(x){ # 테이블 만들 때 빈 자료란은 0으로 채운다
word_table = rep(0, length = length(uniq_words))
word_table = ifelse(uniq_words %in% names(x), x, 0)
}
)
table_list = do.call("rbind", table_list)
refined_table_list = t(table_list[, apply(table_list, 2, sum) != 0])
rownames(refined_table_list) = table_name
groupColors <- brewer.pal(3, "Set3")
chorddiag(refined_table_list
, groupColors = groupColors,  type = "bipartite", tickInterval = 3
,groupnameFontsize = 15)
source('~/.active-rstudio-document', echo=TRUE)
n = 10000
(1+(1/n))^n
exp(1)
x = 1:1500
y = (1+(1/x))^x
plot(y~x, type = 'l')
abline(h = exp(1), col = 'red')
a = 5
x2 = 1:1500
y2 = (1+(a/x2))^x2
plot(y2~x2, type = 'l')
abline(h=exp(a), col = 'blue')
abline(h = exp(1), col = 'red')
x = 1:1500
y = (1+(1/x))^x
plot(y~x, type = 'l')
abline(h = exp(1), col = 'red')
exp(-1 + 0.1*2)
exp(seq(-1, 1, 100))
exp(seq(-1, 1))
exp(seq(-1, 1, length.out = 100))
x3 = seq(-1, 1, length.out = 100)
y3 = exp(x3)
plot()
plot(y3~x3)
plot(y3~x3, type = 'l')
plot(y3~x3, type = 'l', ylim = c(0, 5))
#### matrix
matrix(runif(15), 5, 3)
X[3,2]
#### matrix
X = matrix(runif(15), 5, 3)
X[3,2]
X[,2, drop=F]
X[4, , drop = F]
t(X)
Xt = t(X)
Xt%*%X
X2 = Xt%*%X
X- = solve(X2) # 역행렬
Xinv = solve(X2) # 역행렬
Xinv %*% X2
X2 %*% Xinv
p = 5
n = 4
a = matrix(1:5, p, 1)
X = matrix(1:20, n, p)
t(a) %*% a
t(X) %*% X
solve(t(X) %*% X)
a = matrix(runif(5), p, 1)
X = matrix(runif(20), n, p)
t(a) %*% a
t(X) %*% X
solve(t(X) %*% X)
t(a)%*%solve(t(X) %*% X)%*%a
a
X
t(X) %*% X
p = 5
n = 4
a = matrix(runif(5), p, 1)
X = matrix(runif(20), n, p)
t(a) %*% a
t(X) %*% X
solve(t(X) %*% X)
t(a)%*%solve(t(X) %*% X)%*%a
a = matrix(runif(5, 0, 10), p, 1)
X = matrix(runif(20, 0, 10), n, p)
t(a) %*% a
t(X) %*% X
solve(t(X) %*% X)
t(a)%*%solve(t(X) %*% X)%*%a
mean_mat <- matrix(0, 1, -1)
mean_mat <- matrix(c(0, 1, -1))
mean_mat
cov_mat <- matrix(c(1, 0.5, 0, 0.5, 1, 0.3, 0, 0.3, 1))
cov_mat
cov_mat <- matrix(c(1, 0.5, 0, 0.5, 1, 0.3, 0, 0.3, 1), 3, 3)
cov_mat
x = c(1, 0, 1/2)
X = c(1, 0, 1/2)
mean_mat <- matrix(c(0, 1, -1))
X = matrix(c(1, 0, 1/2))
gX = exp(t(X-mean_mat)%*%t(cov_mat)%*%(X-mean_mat))
gX
gX = exp((t(X-mean_mat)%*%t(cov_mat)%*%(X-mean_mat))/-2) # X가 주어졌을 때 다변량정규분포의 pdf
gX
gX = exp((t(X-mean_mat)%*%solve(t(cov_mat))%*%(X-mean_mat))/-2) # X가 주어졌을 때 다변량정규분포의 pdf
gX
x = seq(0, 10, length.out = 1000)
ppois(x, 1)
plot(py~px, 'l')
plot(py~px, type = 'l')
px = seq(0, 10, length.out = 1000)
py = ppois(px, 1)
plot(py~px, type = 'l')
plot(py~px, type = 's')
abline(h = 1, col = 'red', lty = 2)
py = ppois(px, lambda = 3)
plot(py~px, type = 'l')
plot(py~px, type = 's')
abline(h = 1, col = 'red', lty = 2)
py2 = ppoints(px, lambda = 2)
py = ppois(px, lambda = 1)
px = seq(0, 10, length.out = 1000)
py = ppois(px, lambda = 1)
plot(py~px, type = 'l')
plot(py~px, type = 's')
abline(h = 1, col = 'red', lty = 2)
line(px, py2, type = 'l', col = 'green')
line(px, py2, col = 'green')
abline(px, py2, col = 'green')
py2 = ppois(px, lambda = 2)
abline(px, py2, col = 'green')
abline(px, py2, type = 'l',col = 'green')
lines(px, py2, col = 'green')
px = seq(0, 10, length.out = 1000)
py = ppois(px, lambda = 1)
py2 = ppois(px, lambda = 2)
plot(py~px, type = 'l')
plot(py~px, type = 's')
abline(h = 1, col = 'red', lty = 2)
lines(px, py2, col = 'green')
n = 1000
z = rexp(n)
n = 10000
z = rexp(n)
for (i in 1:1000)
{
idx = sample(1:n, 25)
}
idx
x = c()
for (i in 1:1000)
{
idx = sample(1:n, 25)
x[i] = mean(z[idx])
}
hist(x)
## 감마 분포
gamma(3.1)
gamma(2)
gamma(3)
gamma(4)
gamma(5)
gamma(6)
xg = seq(0, 10, length.out = 100)
yg = gamma(xg, 2, 0.5)
?gamma
yg = gamma( 2, 0.5)
alphag = 2
betag = 0.5
yg = xg^(alphag-1) * (exp(-x/betag)) / (gamma(2)*(betag^alphag))
plot(xg, yg, type = 'l')
alphag = 2
betag = 0.5
Gamma(alphag, betag)
betag = 0.5
Gamma(alphag, betag)
xg = seq(0, 10, length.out = 100)
Gamma(xg, alphag, betag)
?Gamma
?gamma
yg = dgamma(xg, alphag, rate = betag)
plot(xg, yg, type = 'l')
yg2 = dgamma(xg, alphag2, rate = betag)
plot(xg, yg, type = 'l')
lines(xg, yg2, type = 'l')
alphag2 = 8
betag = 0.5
xg = seq(0, 10, length.out = 100)
yg = dgamma(xg, alphag, rate = betag)
yg2 = dgamma(xg, alphag2, rate = betag)
plot(xg, yg, type = 'l')
lines(xg, yg2, type = 'l')
lines(xg, yg2, type = 'l', col = 'red')
yg = dgamma(xg, alphag, rate = betag, log = T)
yg2 = dgamma(xg, alphag2, rate = betag, log = T)
plot(xg, yg, type = 'l')
lines(xg, yg2, type = 'l', col = 'red')
yg = dgamma(xg, alphag, rate = 1/betag, log = T)
yg2 = dgamma(xg, alphag2, rate = 1/betag, log = T)
plot(xg, yg, type = 'l')
yg = dgamma(xg, alphag, rate = 1/betag)
yg2 = dgamma(xg, alphag2, rate = 1/betag)
plot(xg, yg, type = 'l')
lines(xg, yg2, type = 'l', col = 'red')
# Bern MLE estimation
sampl <- c(1,1,0,1,1)
theta <- sum(sampl)/length(sampl)
theta
dbinom(sampl, size = 1, prob = 0.5, log = TRUE)
dbinom(sampl, size = 1, prob = 0.5)
dbinom(sampl, size = 1, prob = 0.5, log = TRUE)
loglike <- like <- c() # make null vector
theta.vec <- seq(0,1, length.out = 100)
thetaNow <- sum(sampl)/length(sampl)
?prod
for (i in 1:100)
{
theta <- theta.vec[i]
like[i] <- prod(dbinom(sampl, size = 1, prob = theta, log = FALSE))
loglike[i] <- prod(dbinom(sampl, size = 1, prob = theta, log = TRUE))
}
plot(theta.vec, like, type = 'l', col = 'blue')
plot(theta.vec, loglike, type = 'l', col = 'red')
plot(theta.vec, like, type = 'l', col = 'blue')
plot(theta.vec, loglike, type = 'l', col = 'red')
?dbinom
plot(theta.vec, like, type = 'l', col = 'blue')
dbinom(sampl, size = 1, prob = 0.5, log = FALSE)
dbinom(sampl, size = 1, prob = 0.6, log = FALSE)
dbinom(sampl, size = 1, prob = 0.8, log = FALSE)
dbinom(sampl, size = 1, prob = 0.6, log = FALSE)
# Norm MLE estimation
sampl_N <- c(0.1, 0.5, 0.3, 0.15, 0.2)
loglike <- like <- c()
theta.vec <- seq(0, 1, length.out = 100)
?dnorm
sampl_N <- c(0.1, 0.5, 0.3, 0.15, 0.2)
loglike <- like <- c()
theta.vec <- seq(0, 1, length.out = 100)
for (i in 1:100)
{
theta <- thata.vec[i]
like[i] <- prod(dnorm(sampl_N, theta, 1, log = FALSE))
loglike[i] <- prod(dnorm(sampl_N, theta, 1, log = TRUE))
}
plot(theta.vec, like, type = 'l', col = 'blue')
plot(theta.vec, loglike, type = 'l', col = 'red')
sampl_N <- c(0.1, 0.5, 0.3, 0.15, 0.2)
loglike <- like <- c()
theta.vec <- seq(0, 1, length.out = 100)
for (i in 1:100)
{
theta <- theta.vec[i]
like[i] <- prod(dnorm(sampl_N, theta, 1, log = FALSE))
loglike[i] <- prod(dnorm(sampl_N, theta, 1, log = TRUE))
}
plot(theta.vec, like, type = 'l', col = 'blue')
plot(theta.vec, loglike, type = 'l', col = 'red')
plot(theta.vec, like, type = 'l', col = 'blue')
mean(sampl_N)
plot(theta.vec, loglike, type = 'l', col = 'red')
# Bern MLE estimation
sampl_B <- c(1,1,0,1,1)
thetaNow <- sum(sampl_B)/length(sampl_B)
dbinom(sampl_B, size = 1, prob = 0.6, log = FALSE)
loglike <- like <- c() # make null vector
theta.vec <- seq(0,1, length.out = 100)
for (i in 1:100)
{
theta <- theta.vec[i]
like[i] <- prod(dbinom(sampl_B, size = 1, prob = theta, log = FALSE)) # multiply all vectors in it
loglike[i] <- sum(dbinom(sampl_B, size = 1, prob = theta, log = TRUE))
}
plot(theta.vec, like, type = 'l', col = 'blue')
plot(theta.vec, loglike, type = 'l', col = 'red')
# Norm MLE estimation given sigma
sampl_N <- c(0.1, 0.5, 0.3, 0.15, 0.2)
loglike <- like <- c()
theta.vec <- seq(0, 1, length.out = 100)
for (i in 1:100)
{
theta <- theta.vec[i]
like[i] <- prod(dnorm(sampl_N, theta, 1, log = FALSE))
loglike[i] <- sum(dnorm(sampl_N, theta, 1, log = TRUE)) # use sum in log forms
}
plot(theta.vec, like, type = 'l', col = 'blue')
plot(theta.vec, loglike, type = 'l', col = 'red')
logsimu <- matrix(0, 100, 100)
# Norm MLE estimation mu and sigma ungiven
sigma.vec <- seq(0, 0.5, length.out = 100)
mu.vec <- seq(-1, 1, length.out = 100)
simu <- matrix(0, 100, 100)
logsimu <- matrix(0, 100, 100)
for (i in 1:100)
{
for (j in 1:100)
{
simu[i, j] = prod(dnorm(sampl_N, mu.vec[i], sigma.vec[j], log = FALSE))
logsimu[i, j] = sum(dnorm(sampl_N, mu.vec[i], sigma.vec[j], log = TRUE))
}
}
filled.contour(mu.vec, sigma.vec, simu, nlevels = 20, col = heat.colors(20))
filled.contour(mu.vec, sigma.vec, logsimu, nlevels = 20, col = heat.colors(20))
# Norm MLE estimation mu and sigma ungiven
sigma.vec <- seq(0, 0.3, length.out = 100)
mu.vec <- seq(-0.5, 1, length.out = 100)
simu <- matrix(0, 100, 100)
logsimu <- matrix(0, 100, 100)
for (i in 1:100)
{
for (j in 1:100)
{
simu[i, j] = prod(dnorm(sampl_N, mu.vec[i], sigma.vec[j], log = FALSE))
logsimu[i, j] = sum(dnorm(sampl_N, mu.vec[i], sigma.vec[j], log = TRUE))
}
}
filled.contour(mu.vec, sigma.vec, simu, nlevels = 20, col = heat.colors(20))
filled.contour(mu.vec, sigma.vec, logsimu, nlevels = 20, col = heat.colors(20))
# Norm MLE estimation mu and sigma ungiven
sigma.vec <- seq(0, 0.3, length.out = 100)
mu.vec <- seq(-0.5, 1, length.out = 100)
simu <- matrix(0, 100, 100)
logsimu <- matrix(0, 100, 100)
for (i in 1:100)
{
for (j in 1:100)
{
simu[i, j] = prod(dnorm(sampl_N, mu.vec[i], sigma.vec[j], log = FALSE), na.rm = TRUE)
logsimu[i, j] = sum(dnorm(sampl_N, mu.vec[i], sigma.vec[j], log = TRUE), na.rm = TRUE)
}
}
filled.contour(mu.vec, sigma.vec, simu, nlevels = 20, col = heat.colors(20))
filled.contour(mu.vec, sigma.vec, logsimu, nlevels = 20, col = heat.colors(20))
filled.contour(mu.vec, sigma.vec, simu, nlevels = 20, col = heat.colors(20))
filled.contour(mu.vec, sigma.vec, logsimu, nlevels = 20, col = heat.colors(20))
filled.contour(mu.vec, sigma.vec, simu, nlevels = 20, col = heat.colors(30))
filled.contour(mu.vec, sigma.vec, logsimu, nlevels = 20, col = heat.colors(30))
filled.contour(mu.vec, sigma.vec, simu, nlevels = 30, col = heat.colors(30))
filled.contour(mu.vec, sigma.vec, logsimu, nlevels = 30, col = heat.colors(30))
sigma.vec <- seq(0.1, 0.3, length.out = 100)
mu.vec <- seq(0, 1, length.out = 100)
simu <- matrix(0, 100, 100)
logsimu <- matrix(0, 100, 100)
for (i in 1:100)
{
for (j in 1:100)
{
simu[i, j] = prod(dnorm(sampl_N, mu.vec[i], sigma.vec[j], log = FALSE), na.rm = TRUE)
logsimu[i, j] = sum(dnorm(sampl_N, mu.vec[i], sigma.vec[j], log = TRUE), na.rm = TRUE)
}
}
filled.contour(mu.vec, sigma.vec, simu, nlevels = 30, col = heat.colors(30))
filled.contour(mu.vec, sigma.vec, logsimu, nlevels = 30, col = heat.colors(30))
filled.contour(mu.vec, sigma.vec, simu, nlevels = 30, col = heat.colors(30))
