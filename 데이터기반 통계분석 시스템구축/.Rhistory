filter(!(words %in% c('amp', 'gt', 'k', 'lt', 'm',  'q', 's', 'x', 'v', 'u', 'a', 'b', 'r', 'www', 'com',
'ne', 'l', 'e', 'd', 'cm', 'https')))
wordcloud2(dfBP2, size = 2, shape = 'star')
# co_occur_mat의 숫자의 강도를 power로 주고 sankey 그래프를 그리자
# 우선 matrix 크기를 줄일 것이다
## diag의 수가 빈도를 의미하기 때문에 diag가 너무 작은 것은 제거한다
inv = (diag(co_occur_mat) >= 40)
co_occur_mat1 <- co_occur_mat[inv, inv]
co_occur_mat1
co_occur_mat1[1:7, 1:7]
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
units = "TWh", fontSize = 18, nodeWidth = 30)
?sankeyNetwork
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
units = "TWh", Group = "group", fontSize = 18, nodeWidth = 30)
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
units = "TWh", LinkGroup = "group", fontSize = 18, nodeWidth = 30)
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
units = "TWh", fontSize = 18, nodeWidth = 20)
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
units = "TWh", fontSize = 20, nodeWidth = 20)
# 지수 with 댄스
theIdx <- which(colnames(co_occur_mat1) %in% c("지수", "안무", "댄스", "제니", "로제", "리사", "매력", "노래", "음악"))
Jisumatrix <- co_occur_mat1[theIdx, theIdx]
Jisumatrix
g = graph.adjacency(Jisumatrix, weighted = T, mode = 'undirected') # 인접행렬 형태에서 igraph 만들기 편하게 해주는 함수
g = simplify(g) # loop나 다중간선 없게
wc = cluster_walktrap(g) # communities(densely connected subgraphs) 찾기
members = membership(wc)
head(co_occurrence)
wc = cluster_walktrap(g) # communities(densely connected subgraphs) 찾기
g = simplify(g) # loop나 다중간선 없게
wc = cluster_walktrap(g) # communities(densely connected subgraphs) 찾기
members = membership(wc)
network_list = igraph_to_networkD3(g, group = members) # igraph to d3 list
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
units = "TWh", fontSize = 20, nodeWidth = 20)
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
units = "TWh", fontSize = 20, nodeWidth = 40)
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
units = "TWh", fontSize = 20, nodeWidth = 100)
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
units = "TWh", fontSize = 20, nodeWidth = 60)
# 지수 with 댄스
theIdx <- which(colnames(co_occur_mat1) %in% c("지수", "안무", "댄스", "매력", "노래", "음악"))
Jisumatrix <- co_occur_mat1[theIdx, theIdx]
g = graph.adjacency(Jisumatrix, weighted = T, mode = 'undirected') # 인접행렬 형태에서 igraph 만들기 편하게 해주는 함수
g = simplify(g) # loop나 다중간선 없게
wc = cluster_walktrap(g) # communities(densely connected subgraphs) 찾기
members = membership(wc)
network_list = igraph_to_networkD3(g, group = members) # igraph to d3 list
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
units = "TWh", fontSize = 20, nodeWidth = 60)
network_list$links$group = network_list$nodes$group[network_list$links$source+1]
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
units = "TWh", fontSize = 20, nodeWidth = 60)
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name", LinkGroup = "group"
units = "TWh", fontSize = 20, nodeWidth = 60)
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name", LinkGroup = "group",
units = "TWh", fontSize = 20, nodeWidth = 60)
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name", LinkGroup = "group",
units = "TWh", fontSize = 20, nodeWidth = 40)
load('data/data_list.Rdata') # 네이쳐에 머신러닝으로 검색한 논문의 단어 정리
str(data_list) # data, n_gram, date, conf_data 로 구성
head(data_list$data)
head(data_list$data$word[data_list$data$date == 2014]) # 2014년도 데이터만
word.df = as.data.frame(data_list$data)
word.df = dcast(word.df, word~date, value.var = "count") # dcast 이용해 wide form으로 변환 (연도 변수를 개별 컬럼들로 만듦)
word.df = cbind(word.df, sum = rowSums(word.df[-1]))
word_order = order(word.df$sum, decreasing = TRUE)
head(word.df[word_order,]) # 합 높은 거 보기 위해
doc_list <- data_list$n_gram
uniq_words <- sort(unique(do.call('c', doc_list))) # c 통해서 vector화 해준 후, unique
count_doc <- function(word, year){
return(
sum(sapply(data_list$n_gram[data_list$date == year], function(x) word %in% x))
# 입력 받은 연도에 해당하는 n_gram들 안에 해당하는 단어의 합
)
}
word_count_2016 <- sapply(uniq_words, function(word) count_doc(word, 2016)) # 모든 unique 단어에 대해
# confidence :  사건 A와 사건 B가 동시에 발생할 확 대비 A 발생 확률 : A 교집합 B의 발생 확률 / A의 발생 확률
# conf_result 설명 : 2014~2016 confidence 평균으로 2017 년의 단어 confidence 비율 파악하려 함
conf_result <- data_list$conf_data
head(conf_result)
mean_conf <- apply(conf_result[,2:4], 1, mean) # conf_result[,2:4]의 열에 대해 평균
conf_result$increasing_rate <- conf_result[,5]/mean_conf
text_conf <- conf_result[c(which(is.finite(conf_result$increasing_rate) & conf_result$increasing_rate > 20),
which(mean_conf > 0.3)),] # 20 넘는 increasing_rate와 mean_conf 가 큰 값들에 text를 입력해주기 위해 미리 설정
loc_conf <- mean_conf[c(which(is.finite(conf_result$increasing_rate) & conf_result$increasing_rate > 20),
which(mean_conf > 0.3))]
sum(conf_result$increasing_rate == Inf) # 102개가 Inf로 나온다
plot(mean_conf, conf_result$increasing_rate, ylim = c(-0.5, 27), xlim = c(-0.01, 0.5))
text(loc_conf+0.03, text_conf$increasing_rate, labels = text_conf$word, cex = 1, pos = 3) # x좌표를 보면 위 과정 이해 될 듯
abline(h=1, col='red')
# x, y 모두 exponential하기 때문에 log scale을 취해준다
# log0은 없기 때문에 아주 작은 수를 더해준다
plot(mean_conf + 1e-4, conf_result$increasing_rate + 1e-2, log = "xy", ylim = c(1e-2, 27), xlim = c(1e-4, 2)) # log = "xy"를 해주면 xy축 모두 로그스케일
text(loc_conf*exp(0.03), text_conf$increasing_rate, labels = text_conf$word, cex = 1, pos = 3)
abline(h = 1, col = 'red')
# Term Document Matrix 만들기 : 특정 Document 컬럼에 Term이 몇 번 나왔는지 나타내는 df
doc_list = data_list$n_gram
uniq_words <- unique(do.call('c', doc_list))
occur_vec_list <- lapply(doc_list, function(x) uniq_words %in% x)
dtm_mat = do.call('rbind', occur_vec_list) # list를 matrix 형으로 바꿔줬음
colnames(dtm_mat) <- uniq_words # uniq_words들의
dtm_mat[1:3, 1:3]
length(dtm_mat) # == nrow * ncol
# nrow(dtm_mat)
# ncol(dtm_mat)
refined_dtm_mat <- dtm_mat[, colSums(dtm_mat) != 0] # 단어 중 문서 전체에서 하나도 안 나온 것은 제거
refined_dtm_mat <- refined_dtm_mat[rowSums(dtm_mat) != 0,]
co_occur_mat <- t(refined_dtm_mat) %*% refined_dtm_mat # 행렬 곱을 통해 특정 단어가 나온 문서에서 다른 특정 단어가 나온 빈도수 표현 (마코브 체인 활용)
# 나오는 결과는 단어 X 단어 matrix
co_occur_mat[1:4, 1:4]
# co_occur_mat의 숫자의 강도를 power로 주고 sankey 그래프를 그리자
# 우선 matrix 크기를 줄일 것이다
## diag의 수가 빈도를 의미하기 때문에 diag가 너무 작은 것은 제거한다
inv = (diag(co_occur_mat) >= 150)
co_occur_mat1 <- co_occur_mat[inv, inv]
network_list = igraph_to_networkD3(g, group = as.character(members)) # igraph to d3 list
network_list$links$group = network_list$nodes$group[network_list$links$source+1]
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name", LinkGroup = "group",
units = "TWh", fontSize = 20, nodeWidth = 40)
network_list
Jisumatrix
Jisumatrix[c(6, 1:5), c(6, 1:5)]
Jisumatrix <- Jisumatrix[c(6, 1:5), c(6, 1:5)]
g = graph.adjacency(Jisumatrix, weighted = T, mode = 'undirected') # 인접행렬 형태에서 igraph 만들기 편하게 해주는 함수
g = simplify(g) # loop나 다중간선 없게
wc = cluster_walktrap(g) # communities(densely connected subgraphs) 찾기
members = membership(wc)
network_list = igraph_to_networkD3(g, group = as.character(members)) # igraph to d3 list
network_list$links$group = network_list$nodes$group[network_list$links$source+1]
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name", LinkGroup = "group",
units = "TWh", fontSize = 20, nodeWidth = 40)
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name", LinkGroup = "group",
units = "TWh", fontSize = 20, nodeWidth = 60)
Jisumatrix <- co_occur_mat1[theIdx, theIdx]
Jisumatrix <- Jisumatrix[c(6, 5, 1:4), c(6, 5, 1:4)]
# 연결관계끼리 관계선을 연결성 느껴지게 그리기. 선후 관계가 없는 관계인데 그냥 먼저 나오는 것의 색을 유지
network_list = igraph_to_networkD3(g, group = as.character(members))
g = graph.adjacency(co_occur_mat1, weighted = T, mode = 'undirected') # 인접행렬 형태에서 igraph 만들기 편하게 해주는 함수
g = simplify(g) # loop나 다중간선 없게
wc = cluster_walktrap(g) # communities(densely connected subgraphs) 찾기
members = membership(wc)
network_list = igraph_to_networkD3(g, group = members) # igraph to d3 list
# 연결관계끼리 관계선을 연결성 느껴지게 그리기. 선후 관계가 없는 관계인데 그냥 먼저 나오는 것의 색을 유지
network_list = igraph_to_networkD3(g, group = as.character(members))
network_list$links$group = network_list$nodes$group[network_list$links$source+1]
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
NodeGroup = "group", LinkGroup = "group",
units = "TWh", fontSize = 18, nodeWidth = 30)
network_list = igraph_to_networkD3(g, group = members) # igraph to d3 list
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
units = "TWh", fontSize = 18, nodeWidth = 30)
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
units = "TWh", fontSize = 20, nodeWidth = 60)
load("dfBP.RData")
# Term Document Matrix 만들기 : 특정 Document 컬럼에 Term이 몇 번 나왔는지 나타내는 df
noun_list = nouns
uniq_words <- unique(do.call('c', noun_list))
occur_vec_list <- lapply(noun_list, function(x) uniq_words %in% x)
dtm_mat = do.call('rbind', occur_vec_list) # list를 matrix 형으로 바꿔줬음
colnames(dtm_mat) <- uniq_words # uniq_words들의
dtm_mat[1:7, 1:7]
length(dtm_mat) # == nrow * ncol
# nrow(dtm_mat)
# ncol(dtm_mat)
refined_dtm_mat <- dtm_mat[, colSums(dtm_mat) != 0] # 단어 중 문서 전체에서 하나도 안 나온 것은 제거
refined_dtm_mat <- refined_dtm_mat[rowSums(dtm_mat) != 0,]
co_occur_mat <- t(refined_dtm_mat) %*% refined_dtm_mat # 행렬 곱을 통해 특정 단어가 나온 문서에서 다른 특정 단어가 나온 빈도수 표현 (마코브 체인 활용)
# 나오는 결과는 단어 X 단어 matrix
co_occur_mat[1:7, 1:7]
# co_occur_mat의 숫자의 강도를 power로 주고 sankey 그래프를 그리자
# 우선 matrix 크기를 줄일 것이다
## diag의 수가 빈도를 의미하기 때문에 diag가 너무 작은 것은 제거한다
inv = (diag(co_occur_mat) >= 40)
co_occur_mat1 <- co_occur_mat[inv, inv]
co_occur_mat1[1:7, 1:7]
noIdx <- which(colnames(co_occur_mat1) %in% c("해", "후", "한", "의", "이", "장", "저", "적", '전', '제', '주', '중', '지',
'은', '을', '위', '월', '원', '세', '수', '로', '만', '명', '본', '분', '라', '데', '도', '두',
'들', '를', '기', '나', '날', '내', '대', '데', '개', '그', '때', '리', '화', '양', '들이',
'듯', '과', '드', '니', '바', '림', '얼', '거', '시', "호", "년", "것", "출처", "번", "속",
'amp', 'cm', 'com', 'gt', 'https', 'k', 'lt', 'm',
'q', 's', 'x', 'v', 'www', 'u', 'a', 'b', 'r',
'ne', 'l', 'e', 'd'))
co_occurrence <- co_occur_mat1[-noIdx, -noIdx]
# 지수 with 댄스
theIdx <- which(colnames(co_occur_mat1) %in% c("지수", "안무", "댄스", "매력", "노래", "음악"))
Jisumatrix <- co_occur_mat1[theIdx, theIdx]
Jisumatrix <- Jisumatrix[c(6, 5, 1:4), c(6, 5, 1:4)]
g = graph.adjacency(Jisumatrix, weighted = T, mode = 'undirected') # 인접행렬 형태에서 igraph 만들기 편하게 해주는 함수
g = simplify(g) # loop나 다중간선 없게
members = membership(wc)
members = membership(wc)
network_list = igraph_to_networkD3(g, group = as.character(members)) # igraph to d3 list
network_list$links$group = network_list$nodes$group[network_list$links$source+1]
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
units = "TWh", fontSize = 20, nodeWidth = 60)
wc = cluster_walktrap(g) # communities(densely connected subgraphs) 찾기
members = membership(wc)
network_list = igraph_to_networkD3(g, group = as.character(members)) # igraph to d3 list
network_list$links$group = network_list$nodes$group[network_list$links$source+1]
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name", LinkGroup = "group",
units = "TWh", fontSize = 20, nodeWidth = 40)
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
units = "TWh", fontSize = 20, nodeWidth = 40)
Jisumatrix
co_occur_mat1[theIdx, theIdx]
Jisumatrix <- Jisumatrix[c(6, 5, 1:4), c(6, 5, 1:4)]
g = graph.adjacency(Jisumatrix, weighted = T, mode = 'undirected') # 인접행렬 형태에서 igraph 만들기 편하게 해주는 함수
g = simplify(g) # loop나 다중간선 없게
wc = cluster_walktrap(g) # communities(densely connected subgraphs) 찾기
members = membership(wc)
network_list = igraph_to_networkD3(g, group = as.character(members)) # igraph to d3 list
network_list$links$group = network_list$nodes$group[network_list$links$source+1]
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
units = "TWh", fontSize = 20, nodeWidth = 40)
Jisumatrix
Jisumatrix <- co_occur_mat1[theIdx, theIdx]
Jisumatrix <- Jisumatrix[c(6, 5, 1:4), c(6, 5, 1:4)]
wc = cluster_walktrap(g) # communities(densely connected subgraphs) 찾기
g = graph.adjacency(Jisumatrix, weighted = T, mode = 'undirected') # 인접행렬 형태에서 igraph 만들기 편하게 해주는 함수
members = membership(wc)
network_list = igraph_to_networkD3(g, group = as.character(members)) # igraph to d3 list
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
units = "TWh", fontSize = 20, nodeWidth = 40)
network_list$links$group = network_list$nodes$group[network_list$links$source+1]
Jisumatrix
co_occur_mat1[theIdx, theIdx]
Jisumatrix <- Jisumatrix[c(6, 5, 4, 1:3), c(6, 5, 4, 1:3)]
# 지수 with 댄스
theIdx <- which(colnames(co_occur_mat1) %in% c("지수", "안무", "댄스", "매력", "노래", "음악"))
Jisumatrix <- co_occur_mat1[theIdx, theIdx]
Jisumatrix <- Jisumatrix[c(6, 5, 4, 1:3), c(6, 5, 4, 1:3)]
g = graph.adjacency(Jisumatrix, weighted = T, mode = 'undirected') # 인접행렬 형태에서 igraph 만들기 편하게 해주는 함수
members = membership(wc)
wc = cluster_walktrap(g) # communities(densely connected subgraphs) 찾기
network_list = igraph_to_networkD3(g, group = as.character(members)) # igraph to d3 list
network_list$links$group = network_list$nodes$group[network_list$links$source+1]
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
units = "TWh", fontSize = 20, nodeWidth = 40)
# co_occur_mat의 숫자의 강도를 power로 주고 sankey 그래프를 그리자
# 우선 matrix 크기를 줄일 것이다
## diag의 수가 빈도를 의미하기 때문에 diag가 너무 작은 것은 제거한다
inv = (diag(co_occur_mat) >= 100)
co_occur_mat1 <- co_occur_mat[inv, inv]
co_occur_mat1[1:7, 1:7]
noIdx <- which(colnames(co_occur_mat1) %in% c("해", "후", "한", "의", "이", "장", "저", "적", '전', '제', '주', '중', '지',
'은', '을', '위', '월', '원', '세', '수', '로', '만', '명', '본', '분', '라', '데', '도', '두',
'들', '를', '기', '나', '날', '내', '대', '데', '개', '그', '때', '리', '화', '양', '들이',
'듯', '과', '드', '니', '바', '림', '얼', '거', '시', "호", "년", "것", "출처", "번", "속",
'amp', 'cm', 'com', 'gt', 'https', 'k', 'lt', 'm',
'q', 's', 'x', 'v', 'www', 'u', 'a', 'b', 'r',
'ne', 'l', 'e', 'd'))
co_occurrence <- co_occur_mat1[-noIdx, -noIdx]
g = graph.adjacency(co_occurrence, weighted = T, mode = 'undirected') # 인접행렬 형태에서 igraph 만들기 편하게 해주는 함수
g = simplify(g) # loop나 다중간선 없게
wc = cluster_walktrap(g) # communities(densely connected subgraphs) 찾기
members = membership(wc)
network_list = igraph_to_networkD3(g, group = members) # igraph to d3 list
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
units = "TWh", fontSize = 20, nodeWidth = 20)
forceNetwork(Links = network_list$links, Nodes = network_list$nodes, NodeID = "name",
Source = "source", Target = "target",
Value = "value", arrows = F,
Group = "group", opacity = 0.8, zoom = TRUE)
# 지수 with 댄스
theIdx <- which(colnames(co_occur_mat1) %in% c("지수", "안무", "댄스", "매력", "노래", "음악"))
Jisumatrix <- Jisumatrix[c(6, 5, 4, 1:3), c(6, 5, 4, 1:3)]
Jisumatrix <- co_occur_mat1[theIdx, theIdx]
g = graph.adjacency(Jisumatrix, weighted = T, mode = 'undirected') # 인접행렬 형태에서 igraph 만들기 편하게 해주는 함수
wc = cluster_walktrap(g) # communities(densely connected subgraphs) 찾기
network_list = igraph_to_networkD3(g, group = as.character(members)) # igraph to d3 list
members = membership(wc)
network_list$links$group = network_list$nodes$group[network_list$links$source+1]
forceNetwork(Links = network_list$links, Nodes = network_list$nodes, NodeID = "name",
Source = "source", Target = "target",
Value = "value", arrows = F,
Group = "group", opacity = 0.8, zoom = TRUE)
# 지수 with 댄스
theIdx <- which(colnames(co_occur_mat1) %in% c("지수", "안무", "댄스", "매력", "노래", "음악"))
Jisumatrix <- co_occur_mat1[theIdx, theIdx]
# 지수 with 댄스
theIdx <- which(colnames(co_occur_mat1) %in% c("지수", "안무", "댄스", "매력", "노래", "음악"))
Jisumatrix <- co_occur_mat1[theIdx, theIdx]
Jisumatrix <- Jisumatrix[c(6, 5, 4, 1:3), c(6, 5, 4, 1:3)]
Jisumatrix
# co_occur_mat의 숫자의 강도를 power로 주고 sankey 그래프를 그리자
# 우선 matrix 크기를 줄일 것이다
## diag의 수가 빈도를 의미하기 때문에 diag가 너무 작은 것은 제거한다
inv = (diag(co_occur_mat) >= 40)
co_occur_mat1 <- co_occur_mat[inv, inv]
co_occur_mat1[1:7, 1:7]
noIdx <- which(colnames(co_occur_mat1) %in% c("해", "후", "한", "의", "이", "장", "저", "적", '전', '제', '주', '중', '지',
'은', '을', '위', '월', '원', '세', '수', '로', '만', '명', '본', '분', '라', '데', '도', '두',
'들', '를', '기', '나', '날', '내', '대', '데', '개', '그', '때', '리', '화', '양', '들이',
'듯', '과', '드', '니', '바', '림', '얼', '거', '시', "호", "년", "것", "출처", "번", "속",
'amp', 'cm', 'com', 'gt', 'https', 'k', 'lt', 'm',
'q', 's', 'x', 'v', 'www', 'u', 'a', 'b', 'r',
'ne', 'l', 'e', 'd'))
co_occurrence <- co_occur_mat1[-noIdx, -noIdx]
theIdx <- which(colnames(co_occur_mat1) %in% c("지수", "안무", "댄스", "매력", "노래", "음악"))
Jisumatrix <- co_occur_mat1[theIdx, theIdx]
Jisumatrix <- Jisumatrix[c(6, 5, 4, 1:3), c(6, 5, 4, 1:3)]
g = graph.adjacency(Jisumatrix, weighted = T, mode = 'undirected') # 인접행렬 형태에서 igraph 만들기 편하게 해주는 함수
wc = cluster_walktrap(g) # communities(densely connected subgraphs) 찾기
members = membership(wc)
network_list = igraph_to_networkD3(g, group = as.character(members)) # igraph to d3 list
network_list$links$group = network_list$nodes$group[network_list$links$source+1]
forceNetwork(Links = network_list$links, Nodes = network_list$nodes, NodeID = "name",
Source = "source", Target = "target",
Value = "value", arrows = F,
Group = "group", opacity = 0.8, zoom = TRUE)
?forceNetwork
forceNetwork(Links = network_list$links, Nodes = network_list$nodes, NodeID = "name",
Source = "source", Target = "target",
Value = "value", arrows = F, fontSize = 20
Group = "group", opacity = 0.8, zoom = TRUE)
forceNetwork(Links = network_list$links, Nodes = network_list$nodes, NodeID = "name",
Source = "source", Target = "target",
Value = "value", arrows = F, fontSize = 20,
Group = "group", opacity = 0.8, zoom = TRUE)
forceNetwork(Links = network_list$links, Nodes = network_list$nodes, NodeID = "name",
Source = "source", Target = "target",
Value = "value", arrows = F, fontSize = 20,
Group = "group", opacity = 0.8, zoom = TRUE, clickAction = MyClickScript)
# 멤버
memberIdx <- which(colnames(co_occur_mat1) %in% c("지수", "제니", "리사", "로제"))
membermatrix <- co_occur_mat1[memberIdx, memberIdx]
g = graph.adjacency(membermatrix, weighted = T, mode = 'undirected') # 인접행렬 형태에서 igraph 만들기 편하게 해주는 함수
wc = cluster_walktrap(g) # communities(densely connected subgraphs) 찾기
members = membership(wc)
network_list = igraph_to_networkD3(g, group = as.character(members)) # igraph to d3 list
network_list$links$group = network_list$nodes$group[network_list$links$source+1]
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
units = "TWh", fontSize = 20, nodeWidth = 40)
# 지수 with 댄스
theIdx <- which(colnames(co_occur_mat1) %in% c("제니", "안무", "댄스", "매력", "노래", "음악"))
Jisumatrix <- co_occur_mat1[theIdx, theIdx]
Jisumatrix <- Jisumatrix[c(6, 5, 4, 1:3), c(6, 5, 4, 1:3)]
g = graph.adjacency(Jisumatrix, weighted = T, mode = 'undirected') # 인접행렬 형태에서 igraph 만들기 편하게 해주는 함수
members = membership(wc)
network_list = igraph_to_networkD3(g, group = as.character(members)) # igraph to d3 list
network_list$links$group = network_list$nodes$group[network_list$links$source+1]
wc = cluster_walktrap(g) # communities(densely connected subgraphs) 찾기
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
units = "TWh", fontSize = 20, nodeWidth = 40)
# 지수 with 댄스
theIdx <- which(colnames(co_occur_mat1) %in% c("제니", "안무", "댄스", "매력", "노래", "음악"))
Jisumatrix <- co_occur_mat1[theIdx, theIdx]
Jisumatrix <- Jisumatrix[c(6, 5, 4, 1:3), c(6, 5, 4, 1:3)]
g = graph.adjacency(Jisumatrix, weighted = T, mode = 'undirected') # 인접행렬 형태에서 igraph 만들기 편하게 해주는 함수
wc = cluster_walktrap(g) # communities(densely connected subgraphs) 찾기
members = membership(wc)
network_list = igraph_to_networkD3(g, group = as.character(members)) # igraph to d3 list
network_list$links$group = network_list$nodes$group[network_list$links$source+1]
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
units = "TWh", fontSize = 20, nodeWidth = 40)
# 지수 with 댄스
theIdx <- which(colnames(co_occur_mat1) %in% c("로제", "안무", "댄스", "매력", "노래", "음악"))
Jisumatrix <- co_occur_mat1[theIdx, theIdx]
Jisumatrix <- Jisumatrix[c(6, 5, 4, 1:3), c(6, 5, 4, 1:3)]
g = graph.adjacency(Jisumatrix, weighted = T, mode = 'undirected') # 인접행렬 형태에서 igraph 만들기 편하게 해주는 함수
wc = cluster_walktrap(g) # communities(densely connected subgraphs) 찾기
members = membership(wc)
network_list = igraph_to_networkD3(g, group = as.character(members)) # igraph to d3 list
network_list$links$group = network_list$nodes$group[network_list$links$source+1]
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
units = "TWh", fontSize = 20, nodeWidth = 40)
# 지수 with 댄스
theIdx <- which(colnames(co_occur_mat1) %in% c("리사", "안무", "댄스", "매력", "노래", "음악"))
Jisumatrix <- co_occur_mat1[theIdx, theIdx]
Jisumatrix <- Jisumatrix[c(6, 5, 4, 1:3), c(6, 5, 4, 1:3)]
g = graph.adjacency(Jisumatrix, weighted = T, mode = 'undirected') # 인접행렬 형태에서 igraph 만들기 편하게 해주는 함수
wc = cluster_walktrap(g) # communities(densely connected subgraphs) 찾기
members = membership(wc)
network_list = igraph_to_networkD3(g, group = as.character(members)) # igraph to d3 list
network_list$links$group = network_list$nodes$group[network_list$links$source+1]
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
units = "TWh", fontSize = 20, nodeWidth = 40)
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
units = "TWh", fontSize = 100, nodeWidth = 40)
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
units = "TWh", fontSize = 50, nodeWidth = 40)
# 지수 with 댄스
theIdx <- which(colnames(co_occur_mat1) %in% c("로제", "안무", "댄스", "매력", "노래", "음악"))
Jisumatrix <- co_occur_mat1[theIdx, theIdx]
Jisumatrix <- Jisumatrix[c(6, 5, 4, 1:3), c(6, 5, 4, 1:3)]
g = graph.adjacency(Jisumatrix, weighted = T, mode = 'undirected') # 인접행렬 형태에서 igraph 만들기 편하게 해주는 함수
wc = cluster_walktrap(g) # communities(densely connected subgraphs) 찾기
members = membership(wc)
network_list = igraph_to_networkD3(g, group = as.character(members)) # igraph to d3 list
network_list$links$group = network_list$nodes$group[network_list$links$source+1]
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
units = "TWh", fontSize = 20, nodeWidth = 40)
forceNetwork(Links = network_list$links, Nodes = network_list$nodes, NodeID = "name",
Source = "source", Target = "target",
Value = "value", arrows = F, fontSize = 20,
Group = "group", opacity = 0.8, zoom = TRUE)
# 지수 with 댄스
theIdx <- which(colnames(co_occur_mat1) %in% c("제니", "안무", "댄스", "매력", "노래", "음악"))
Jisumatrix <- co_occur_mat1[theIdx, theIdx]
g = graph.adjacency(Jisumatrix, weighted = T, mode = 'undirected') # 인접행렬 형태에서 igraph 만들기 편하게 해주는 함수
Jisumatrix <- Jisumatrix[c(6, 5, 4, 1:3), c(6, 5, 4, 1:3)]
wc = cluster_walktrap(g) # communities(densely connected subgraphs) 찾기
members = membership(wc)
network_list = igraph_to_networkD3(g, group = as.character(members)) # igraph to d3 list
network_list$links$group = network_list$nodes$group[network_list$links$source+1]
forceNetwork(Links = network_list$links, Nodes = network_list$nodes, NodeID = "name",
Source = "source", Target = "target",
Value = "value", arrows = F, fontSize = 20,
Group = "group", opacity = 0.8, zoom = TRUE)
# 지수 with 댄스
theIdx <- which(colnames(co_occur_mat1) %in% c("리사", "안무", "댄스", "매력", "노래", "음악"))
Jisumatrix <- co_occur_mat1[theIdx, theIdx]
g = graph.adjacency(Jisumatrix, weighted = T, mode = 'undirected') # 인접행렬 형태에서 igraph 만들기 편하게 해주는 함수
wc = cluster_walktrap(g) # communities(densely connected subgraphs) 찾기
Jisumatrix <- Jisumatrix[c(6, 5, 4, 1:3), c(6, 5, 4, 1:3)]
members = membership(wc)
network_list = igraph_to_networkD3(g, group = as.character(members)) # igraph to d3 list
network_list$links$group = network_list$nodes$group[network_list$links$source+1]
forceNetwork(Links = network_list$links, Nodes = network_list$nodes, NodeID = "name",
Source = "source", Target = "target",
Value = "value", arrows = F, fontSize = 20,
Group = "group", opacity = 0.8, zoom = TRUE)
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
units = "TWh", fontSize = 20, nodeWidth = 40)
# 멤버
memberIdx <- which(colnames(co_occur_mat1) %in% c("지수", "제니", "리사", "로제"))
membermatrix <- co_occur_mat1[memberIdx, memberIdx]
g = graph.adjacency(membermatrix, weighted = T, mode = 'undirected') # 인접행렬 형태에서 igraph 만들기 편하게 해주는 함수
wc = cluster_walktrap(g) # communities(densely connected subgraphs) 찾기
members = membership(wc)
network_list = igraph_to_networkD3(g, group = as.character(members)) # igraph to d3 list
network_list$links$group = network_list$nodes$group[network_list$links$source+1]
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
units = "TWh", fontSize = 20, nodeWidth = 40)
