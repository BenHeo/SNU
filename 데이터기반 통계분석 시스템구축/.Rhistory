network_list$links$group = network_list$nodes$group[network_list$links$source+1]
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name", LinkGroup = "group",
units = "TWh", fontSize = 20, nodeWidth = 40)
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
units = "TWh", fontSize = 20, nodeWidth = 40)
Jisumatrix
co_occur_mat1[theIdx, theIdx]
Jisumatrix <- Jisumatrix[c(6, 5, 1:4), c(6, 5, 1:4)]
g = graph.adjacency(Jisumatrix, weighted = T, mode = 'undirected') # 인접행렬 형태에서 igraph 만들기 편하게 해주는 함수
g = simplify(g) # loop나 다중간선 없게
wc = cluster_walktrap(g) # communities(densely connected subgraphs) 찾기
members = membership(wc)
network_list = igraph_to_networkD3(g, group = as.character(members)) # igraph to d3 list
network_list$links$group = network_list$nodes$group[network_list$links$source+1]
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
units = "TWh", fontSize = 20, nodeWidth = 40)
Jisumatrix
Jisumatrix <- co_occur_mat1[theIdx, theIdx]
Jisumatrix <- Jisumatrix[c(6, 5, 1:4), c(6, 5, 1:4)]
wc = cluster_walktrap(g) # communities(densely connected subgraphs) 찾기
g = graph.adjacency(Jisumatrix, weighted = T, mode = 'undirected') # 인접행렬 형태에서 igraph 만들기 편하게 해주는 함수
members = membership(wc)
network_list = igraph_to_networkD3(g, group = as.character(members)) # igraph to d3 list
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
units = "TWh", fontSize = 20, nodeWidth = 40)
network_list$links$group = network_list$nodes$group[network_list$links$source+1]
Jisumatrix
co_occur_mat1[theIdx, theIdx]
Jisumatrix <- Jisumatrix[c(6, 5, 4, 1:3), c(6, 5, 4, 1:3)]
# 지수 with 댄스
theIdx <- which(colnames(co_occur_mat1) %in% c("지수", "안무", "댄스", "매력", "노래", "음악"))
Jisumatrix <- co_occur_mat1[theIdx, theIdx]
Jisumatrix <- Jisumatrix[c(6, 5, 4, 1:3), c(6, 5, 4, 1:3)]
g = graph.adjacency(Jisumatrix, weighted = T, mode = 'undirected') # 인접행렬 형태에서 igraph 만들기 편하게 해주는 함수
members = membership(wc)
wc = cluster_walktrap(g) # communities(densely connected subgraphs) 찾기
network_list = igraph_to_networkD3(g, group = as.character(members)) # igraph to d3 list
network_list$links$group = network_list$nodes$group[network_list$links$source+1]
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
units = "TWh", fontSize = 20, nodeWidth = 40)
# co_occur_mat의 숫자의 강도를 power로 주고 sankey 그래프를 그리자
# 우선 matrix 크기를 줄일 것이다
## diag의 수가 빈도를 의미하기 때문에 diag가 너무 작은 것은 제거한다
inv = (diag(co_occur_mat) >= 100)
co_occur_mat1 <- co_occur_mat[inv, inv]
co_occur_mat1[1:7, 1:7]
noIdx <- which(colnames(co_occur_mat1) %in% c("해", "후", "한", "의", "이", "장", "저", "적", '전', '제', '주', '중', '지',
'은', '을', '위', '월', '원', '세', '수', '로', '만', '명', '본', '분', '라', '데', '도', '두',
'들', '를', '기', '나', '날', '내', '대', '데', '개', '그', '때', '리', '화', '양', '들이',
'듯', '과', '드', '니', '바', '림', '얼', '거', '시', "호", "년", "것", "출처", "번", "속",
'amp', 'cm', 'com', 'gt', 'https', 'k', 'lt', 'm',
'q', 's', 'x', 'v', 'www', 'u', 'a', 'b', 'r',
'ne', 'l', 'e', 'd'))
co_occurrence <- co_occur_mat1[-noIdx, -noIdx]
g = graph.adjacency(co_occurrence, weighted = T, mode = 'undirected') # 인접행렬 형태에서 igraph 만들기 편하게 해주는 함수
g = simplify(g) # loop나 다중간선 없게
wc = cluster_walktrap(g) # communities(densely connected subgraphs) 찾기
members = membership(wc)
network_list = igraph_to_networkD3(g, group = members) # igraph to d3 list
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
units = "TWh", fontSize = 20, nodeWidth = 20)
forceNetwork(Links = network_list$links, Nodes = network_list$nodes, NodeID = "name",
Source = "source", Target = "target",
Value = "value", arrows = F,
Group = "group", opacity = 0.8, zoom = TRUE)
# 지수 with 댄스
theIdx <- which(colnames(co_occur_mat1) %in% c("지수", "안무", "댄스", "매력", "노래", "음악"))
Jisumatrix <- Jisumatrix[c(6, 5, 4, 1:3), c(6, 5, 4, 1:3)]
Jisumatrix <- co_occur_mat1[theIdx, theIdx]
g = graph.adjacency(Jisumatrix, weighted = T, mode = 'undirected') # 인접행렬 형태에서 igraph 만들기 편하게 해주는 함수
wc = cluster_walktrap(g) # communities(densely connected subgraphs) 찾기
network_list = igraph_to_networkD3(g, group = as.character(members)) # igraph to d3 list
members = membership(wc)
network_list$links$group = network_list$nodes$group[network_list$links$source+1]
forceNetwork(Links = network_list$links, Nodes = network_list$nodes, NodeID = "name",
Source = "source", Target = "target",
Value = "value", arrows = F,
Group = "group", opacity = 0.8, zoom = TRUE)
# 지수 with 댄스
theIdx <- which(colnames(co_occur_mat1) %in% c("지수", "안무", "댄스", "매력", "노래", "음악"))
Jisumatrix <- co_occur_mat1[theIdx, theIdx]
# 지수 with 댄스
theIdx <- which(colnames(co_occur_mat1) %in% c("지수", "안무", "댄스", "매력", "노래", "음악"))
Jisumatrix <- co_occur_mat1[theIdx, theIdx]
Jisumatrix <- Jisumatrix[c(6, 5, 4, 1:3), c(6, 5, 4, 1:3)]
Jisumatrix
# co_occur_mat의 숫자의 강도를 power로 주고 sankey 그래프를 그리자
# 우선 matrix 크기를 줄일 것이다
## diag의 수가 빈도를 의미하기 때문에 diag가 너무 작은 것은 제거한다
inv = (diag(co_occur_mat) >= 40)
co_occur_mat1 <- co_occur_mat[inv, inv]
co_occur_mat1[1:7, 1:7]
noIdx <- which(colnames(co_occur_mat1) %in% c("해", "후", "한", "의", "이", "장", "저", "적", '전', '제', '주', '중', '지',
'은', '을', '위', '월', '원', '세', '수', '로', '만', '명', '본', '분', '라', '데', '도', '두',
'들', '를', '기', '나', '날', '내', '대', '데', '개', '그', '때', '리', '화', '양', '들이',
'듯', '과', '드', '니', '바', '림', '얼', '거', '시', "호", "년", "것", "출처", "번", "속",
'amp', 'cm', 'com', 'gt', 'https', 'k', 'lt', 'm',
'q', 's', 'x', 'v', 'www', 'u', 'a', 'b', 'r',
'ne', 'l', 'e', 'd'))
co_occurrence <- co_occur_mat1[-noIdx, -noIdx]
theIdx <- which(colnames(co_occur_mat1) %in% c("지수", "안무", "댄스", "매력", "노래", "음악"))
Jisumatrix <- co_occur_mat1[theIdx, theIdx]
Jisumatrix <- Jisumatrix[c(6, 5, 4, 1:3), c(6, 5, 4, 1:3)]
g = graph.adjacency(Jisumatrix, weighted = T, mode = 'undirected') # 인접행렬 형태에서 igraph 만들기 편하게 해주는 함수
wc = cluster_walktrap(g) # communities(densely connected subgraphs) 찾기
members = membership(wc)
network_list = igraph_to_networkD3(g, group = as.character(members)) # igraph to d3 list
network_list$links$group = network_list$nodes$group[network_list$links$source+1]
forceNetwork(Links = network_list$links, Nodes = network_list$nodes, NodeID = "name",
Source = "source", Target = "target",
Value = "value", arrows = F,
Group = "group", opacity = 0.8, zoom = TRUE)
?forceNetwork
forceNetwork(Links = network_list$links, Nodes = network_list$nodes, NodeID = "name",
Source = "source", Target = "target",
Value = "value", arrows = F, fontSize = 20
Group = "group", opacity = 0.8, zoom = TRUE)
forceNetwork(Links = network_list$links, Nodes = network_list$nodes, NodeID = "name",
Source = "source", Target = "target",
Value = "value", arrows = F, fontSize = 20,
Group = "group", opacity = 0.8, zoom = TRUE)
forceNetwork(Links = network_list$links, Nodes = network_list$nodes, NodeID = "name",
Source = "source", Target = "target",
Value = "value", arrows = F, fontSize = 20,
Group = "group", opacity = 0.8, zoom = TRUE, clickAction = MyClickScript)
# 멤버
memberIdx <- which(colnames(co_occur_mat1) %in% c("지수", "제니", "리사", "로제"))
membermatrix <- co_occur_mat1[memberIdx, memberIdx]
g = graph.adjacency(membermatrix, weighted = T, mode = 'undirected') # 인접행렬 형태에서 igraph 만들기 편하게 해주는 함수
wc = cluster_walktrap(g) # communities(densely connected subgraphs) 찾기
members = membership(wc)
network_list = igraph_to_networkD3(g, group = as.character(members)) # igraph to d3 list
network_list$links$group = network_list$nodes$group[network_list$links$source+1]
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
units = "TWh", fontSize = 20, nodeWidth = 40)
# 지수 with 댄스
theIdx <- which(colnames(co_occur_mat1) %in% c("제니", "안무", "댄스", "매력", "노래", "음악"))
Jisumatrix <- co_occur_mat1[theIdx, theIdx]
Jisumatrix <- Jisumatrix[c(6, 5, 4, 1:3), c(6, 5, 4, 1:3)]
g = graph.adjacency(Jisumatrix, weighted = T, mode = 'undirected') # 인접행렬 형태에서 igraph 만들기 편하게 해주는 함수
members = membership(wc)
network_list = igraph_to_networkD3(g, group = as.character(members)) # igraph to d3 list
network_list$links$group = network_list$nodes$group[network_list$links$source+1]
wc = cluster_walktrap(g) # communities(densely connected subgraphs) 찾기
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
units = "TWh", fontSize = 20, nodeWidth = 40)
# 지수 with 댄스
theIdx <- which(colnames(co_occur_mat1) %in% c("제니", "안무", "댄스", "매력", "노래", "음악"))
Jisumatrix <- co_occur_mat1[theIdx, theIdx]
Jisumatrix <- Jisumatrix[c(6, 5, 4, 1:3), c(6, 5, 4, 1:3)]
g = graph.adjacency(Jisumatrix, weighted = T, mode = 'undirected') # 인접행렬 형태에서 igraph 만들기 편하게 해주는 함수
wc = cluster_walktrap(g) # communities(densely connected subgraphs) 찾기
members = membership(wc)
network_list = igraph_to_networkD3(g, group = as.character(members)) # igraph to d3 list
network_list$links$group = network_list$nodes$group[network_list$links$source+1]
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
units = "TWh", fontSize = 20, nodeWidth = 40)
# 지수 with 댄스
theIdx <- which(colnames(co_occur_mat1) %in% c("로제", "안무", "댄스", "매력", "노래", "음악"))
Jisumatrix <- co_occur_mat1[theIdx, theIdx]
Jisumatrix <- Jisumatrix[c(6, 5, 4, 1:3), c(6, 5, 4, 1:3)]
g = graph.adjacency(Jisumatrix, weighted = T, mode = 'undirected') # 인접행렬 형태에서 igraph 만들기 편하게 해주는 함수
wc = cluster_walktrap(g) # communities(densely connected subgraphs) 찾기
members = membership(wc)
network_list = igraph_to_networkD3(g, group = as.character(members)) # igraph to d3 list
network_list$links$group = network_list$nodes$group[network_list$links$source+1]
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
units = "TWh", fontSize = 20, nodeWidth = 40)
# 지수 with 댄스
theIdx <- which(colnames(co_occur_mat1) %in% c("리사", "안무", "댄스", "매력", "노래", "음악"))
Jisumatrix <- co_occur_mat1[theIdx, theIdx]
Jisumatrix <- Jisumatrix[c(6, 5, 4, 1:3), c(6, 5, 4, 1:3)]
g = graph.adjacency(Jisumatrix, weighted = T, mode = 'undirected') # 인접행렬 형태에서 igraph 만들기 편하게 해주는 함수
wc = cluster_walktrap(g) # communities(densely connected subgraphs) 찾기
members = membership(wc)
network_list = igraph_to_networkD3(g, group = as.character(members)) # igraph to d3 list
network_list$links$group = network_list$nodes$group[network_list$links$source+1]
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
units = "TWh", fontSize = 20, nodeWidth = 40)
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
units = "TWh", fontSize = 100, nodeWidth = 40)
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
units = "TWh", fontSize = 50, nodeWidth = 40)
# 지수 with 댄스
theIdx <- which(colnames(co_occur_mat1) %in% c("로제", "안무", "댄스", "매력", "노래", "음악"))
Jisumatrix <- co_occur_mat1[theIdx, theIdx]
Jisumatrix <- Jisumatrix[c(6, 5, 4, 1:3), c(6, 5, 4, 1:3)]
g = graph.adjacency(Jisumatrix, weighted = T, mode = 'undirected') # 인접행렬 형태에서 igraph 만들기 편하게 해주는 함수
wc = cluster_walktrap(g) # communities(densely connected subgraphs) 찾기
members = membership(wc)
network_list = igraph_to_networkD3(g, group = as.character(members)) # igraph to d3 list
network_list$links$group = network_list$nodes$group[network_list$links$source+1]
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
units = "TWh", fontSize = 20, nodeWidth = 40)
forceNetwork(Links = network_list$links, Nodes = network_list$nodes, NodeID = "name",
Source = "source", Target = "target",
Value = "value", arrows = F, fontSize = 20,
Group = "group", opacity = 0.8, zoom = TRUE)
# 지수 with 댄스
theIdx <- which(colnames(co_occur_mat1) %in% c("제니", "안무", "댄스", "매력", "노래", "음악"))
Jisumatrix <- co_occur_mat1[theIdx, theIdx]
g = graph.adjacency(Jisumatrix, weighted = T, mode = 'undirected') # 인접행렬 형태에서 igraph 만들기 편하게 해주는 함수
Jisumatrix <- Jisumatrix[c(6, 5, 4, 1:3), c(6, 5, 4, 1:3)]
wc = cluster_walktrap(g) # communities(densely connected subgraphs) 찾기
members = membership(wc)
network_list = igraph_to_networkD3(g, group = as.character(members)) # igraph to d3 list
network_list$links$group = network_list$nodes$group[network_list$links$source+1]
forceNetwork(Links = network_list$links, Nodes = network_list$nodes, NodeID = "name",
Source = "source", Target = "target",
Value = "value", arrows = F, fontSize = 20,
Group = "group", opacity = 0.8, zoom = TRUE)
# 지수 with 댄스
theIdx <- which(colnames(co_occur_mat1) %in% c("리사", "안무", "댄스", "매력", "노래", "음악"))
Jisumatrix <- co_occur_mat1[theIdx, theIdx]
g = graph.adjacency(Jisumatrix, weighted = T, mode = 'undirected') # 인접행렬 형태에서 igraph 만들기 편하게 해주는 함수
wc = cluster_walktrap(g) # communities(densely connected subgraphs) 찾기
Jisumatrix <- Jisumatrix[c(6, 5, 4, 1:3), c(6, 5, 4, 1:3)]
members = membership(wc)
network_list = igraph_to_networkD3(g, group = as.character(members)) # igraph to d3 list
network_list$links$group = network_list$nodes$group[network_list$links$source+1]
forceNetwork(Links = network_list$links, Nodes = network_list$nodes, NodeID = "name",
Source = "source", Target = "target",
Value = "value", arrows = F, fontSize = 20,
Group = "group", opacity = 0.8, zoom = TRUE)
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
units = "TWh", fontSize = 20, nodeWidth = 40)
# 멤버
memberIdx <- which(colnames(co_occur_mat1) %in% c("지수", "제니", "리사", "로제"))
membermatrix <- co_occur_mat1[memberIdx, memberIdx]
g = graph.adjacency(membermatrix, weighted = T, mode = 'undirected') # 인접행렬 형태에서 igraph 만들기 편하게 해주는 함수
wc = cluster_walktrap(g) # communities(densely connected subgraphs) 찾기
members = membership(wc)
network_list = igraph_to_networkD3(g, group = as.character(members)) # igraph to d3 list
network_list$links$group = network_list$nodes$group[network_list$links$source+1]
sankeyNetwork(Links = network_list$links, Nodes = network_list$nodes,
Source = "source", Target = "target",
Value = "value", NodeID = "name",
units = "TWh", fontSize = 20, nodeWidth = 40)
source('C:/Users/asd/Desktop/데이터 사이언스/SNU/데이터기반 통계분석 시스템구축/WhiteWine.R', echo=TRUE)
hist(quality, breaks = 20) # discrete data, unbalance exists between data
subset(quality, 3)
subset(quality==3)
subset(quality=3)
?subset
subset(white, quality == 3)
boxplot(log(volatile_acidity)~quality, col = 3:9)
hist(volatile_acidity, breaks = 20) # right skew
hist(log(volatile_acidity), breaks = 20) # right skew
hist(citric_acid, breaks = 30) # # outliers
boxplot(citric_acid~quality, col = 3:9)
boxplot(sqrt(citric_acid)~quality, col = 3:9)
hist(log(citric_acid), breaks = 30) # # outliers
hist(sqrt(citric_acid), breaks = 30) # # outliers
hist(citric_acid, breaks = 30) # outliers
hist(residual_sugar, breaks = 10) # right skew
hist(chlorides, breaks = 20) # some ranges have large number of observations ==> better to log
hist(log(residual_sugar), breaks = 10) # right skew
hist(exp(residual_sugar), breaks = 10) # right skew
hist((residual_sugar)^2, breaks = 10) # right skew
hist(residual_sugar, breaks = 10) # right skew
(residual_sugar)^2
hist((residual_sugar)^2, breaks = 10) # right skew
hist((residual_sugar)^2, breaks = 100) # right skew
hist(exp(residual_sugar), breaks = 100) # right skew
hist(log(residual_sugar), breaks = 100) # right skew
hist(sqrt(residual_sugar), breaks = 100) # right skew
hist((residual_sugar), breaks = 100) # right skew
hist(log(residual_sugar), breaks = 100) # right skew
hist(log(residual_sugar), breaks = 50) # right skew
hist(residual_sugar, breaks = 50) # right skew
hist(log(residual_sugar), breaks = 50) # two modes
hist(chlorides, breaks = 20) # some ranges have large number of observations ==> better to log
hist(log(chlorides), breaks = 20) # some ranges have large number of observations ==> better to log
hist(free_sulfur_dioxide, breaks = 30) # almost normal
hist(log(free_sulfur_dioxide), breaks = 30) # almost normal
hist(sqrt(free_sulfur_dioxide), breaks = 30) # almost normal
hist(free_sulfur_dioxide, breaks = 30) # almost normal
hist(sqrt(free_sulfur_dioxide), breaks = 30) # almost normal
hist(total_sulfur_dioxide, breaks = 20) # normal
hist(total_sulfur_dioxide, breaks = 20) # normal
hist(sqrt(free_sulfur_dioxide), breaks = 30) # almost normal
hist(total_sulfur_dioxide, breaks = 20) # normal
hist(density, breaks = 20) # normal but outliers
hist(log(density), breaks = 20) # normal but outliers
hist(sqrt(density), breaks = 20) # normal but outliers
hist(log(density), breaks = 20) # normal but outliers
white$density[white$density>0.01]
hist(density, breaks = 100) # normal but outliers
hist(density, breaks = 1000) # normal but outliers
hist(density, breaks = 50) # normal but outliers
hist(density, breaks = 10) # normal but outliers
hist(density, breaks = 20) # normal but outliers
hist(density, breaks = 50) # normal but outliers
white$density[white$density>1.01]
hist(pH, breaks = 20) # normal
hist(sulphates, breaks = 20) # normal
hist(sqrt(sulphates), breaks = 20) # normal
hist(log(sulphates), breaks = 20) # normal
hist(alcohol, breaks = 30) # almost normal
hist((alcohol)^2, breaks = 30) # almost normal
hist(log(alcohol), breaks = 30) # almost normal
hist(sqrt(alcohol), breaks = 30) # almost normal
hist(log(alcohol), breaks = 30) # almost normal
hist(log(alcohol)^2, breaks = 30) # almost normal
alcohol
hist(alcohol, breaks = 30) # almost normal
hist(alcohol, breaks = 50) # almost normal
hist(alcohol^(1/3), breaks = 50) # three main curves
hist(alcohol^(1/4), breaks = 50) # three main curves
hist(alcohol^(1/5), breaks = 50) # three main curves
hist(alcohol^(3), breaks = 50) # three main curves
hist(alcohol^(5), breaks = 50) # three main curves
hist(exp(alcohol), breaks = 50) # three main curves
hist(alcohol, breaks = 50) # three main curves
hist(quality, breaks = 20) # discrete data, unbalance exists between data
# draw boxplots about quality
boxplot(fixed_acidity~quality, col = 3:9)
boxplot(log(volatile_acidity)~quality, col = 3:9)
boxplot((volatile_acidity)~quality, col = 3:9)
boxplot(log(volatile_acidity)~quality, col = 3:9)
makingplot <- function(dataset){
a = boxplot(dataset~red_wine$quality, main = ='histo', col = 'lightblue',
xlab = 'quality'))
}
makingplot <- function(dataset){
a = boxplot(dataset~red_wine$quality, main = 'histo', col = 'lightblue',
xlab = 'quality')
}
makingplot(citric_acid)
a = boxplot(dataset~white$quality, main = 'histo', col = 'lightblue',
xlab = 'quality')
makingplot <- function(dataset){
a = boxplot(dataset~white$quality, main = 'histo', col = 'lightblue',
xlab = 'quality')
}
makingplot(citric_acid)
boxplot(alcohol~quality, col = 3:9)
boxplot(sulphates~quality, col = 3:9)
boxplot(log(sulphates)~quality, col = 3:9)
boxplot(pH~quality, col = 3:9)
boxplot(density~quality, col = 3:9)
boxplot(free_sulfur_dioxide~quality, col = 3:9)
boxplot(sqrt(free_sulfur_dioxide)~quality, col = 3:9)
boxplot(log(chlorides)~quality, col = 3:9)
boxplot((chlorides)~quality, col = 3:9)
boxplot(log(chlorides)~quality, col = 3:9)
# draw histograms
hist(fixed_acidity, breaks = 20) # normal with outliers
library(tidyverse)
white <- read.csv('data/winequality-white.csv', sep = ';')
names(white) <- c("fixed_acidity", "volatile_acidity", "citric_acid", "residual_sugar", "chlorides", "free_sulfur_dioxide",
"total_sulfur_dioxide", "density", "pH", "sulphates", "alcohol", "quality" )
attach(white)
# draw histograms
hist(fixed_acidity, breaks = 20) # normal with outliers
white$fixed_acidity[white$fixed_acidity>10.5]
boxplot(fixed_acidity)
hist(volatile_acidity, breaks = 20) # right skew
hist(log(volatile_acidity), breaks = 20) # normal
boxplot(log(volatile_acidity))
# draw histograms
hist(fixed_acidity, breaks = 20, freq = F) # normal with outliers
# draw histograms
hist(fixed_acidity, breaks = 20) # normal with outliers
# 단맛, 신맛, 짠맛, 산화제로 나눌 수 있음
# 산화제는 높으면 오래 보존되지만, 몸에 해롭다
# 짠맛은 영향력이 없는 것 같다(왜냐하면 짠맛을 느끼기 어렵다)
plot(quality~chlorides)
plot(quality~residual_sugar)
plot(quality~density)
# draw boxplots about quality
boxplot(fixed_acidity~quality, col = 3:9)
boxplot(log(volatile_acidity)~quality, col = 3:9)
boxplot(sqrt(citric_acid)~quality, col = 3:9)
boxplot(residual_sugar~quality, col = 3:9)
boxplot(chlorides~quality, col = 3:9)
boxplot(log(chlorides)~quality, col = 3:9)
boxplot(sqrt(free_sulfur_dioxide)~quality, col = 3:9)
boxplot(total_sulfur_dioxide~quality, col = 3:9)
boxplot(density~quality, col = 3:9)
boxplot(pH~quality, col = 3:9)
boxplot(log(sulphates)~quality, col = 3:9)
boxplot(alcohol~quality, col = 3:9)
plot(quality~alcohol)
boxplot(alcohol~quality, col = 3:9)
boxplot(log(sulphates)~quality, col = 3:9)
boxplot(pH~quality, col = 3:9)
boxplot(sulphates~quality, col = 3:9)
?fancy
??fancy
table(quality) # 20  163  1457  2198  880  175  5
plot(density~residual_sugar)
lm(density~residual_sugar)
plot(density~residual_sugar, log = 'xy')
plot(density~sqrt(residual_sugar), log = 'xy')
lm(log(density)~log(residual_sugar))
dr <- lm(density~residual_sugar)
summary(dr)
cor(white)
corwhite <- cor(white)
lm(quality~density + residual_sugar + alcohol)
testlm <- lm(quality~density + residual_sugar + alcohol)
summary(testlm)
total <- lm(quality~.)
total <- lm(quality~., white)
summary(total)
boxplot(sqrt(citric_acid)~quality, col = 3:9)
boxplot(citric_acid~quality, col = 3:9)
table(quality) # 20  163  1457  2198  880  175  5
corwhite <- cor(white)
install.packages("corplot")
library(corplot)
install.packages("corrplot")
library(corrplot)
corrplot(corwhite)
# save(nouns, file = "BlackPinkNouns.RData")
load("BlackPinkNouns.RData")
# class(final_dat)
length(nouns)
nouns[[1]]
words <- c()
for (i in 1:1000){
for (word in nouns[[i]]){
words <- c(words, tolower(word))
}
}
tw <- table(words)
length(tw)
sort(tw, decreasing = TRUE)
head(sort(tw, decreasing = TRUE))
head(white)
library(tidyverse)
white <- read.csv('data/winequality-white.csv', sep = ';')
names(white) <- c("fixed_acidity", "volatile_acidity", "citric_acid", "residual_sugar", "chlorides", "free_sulfur_dioxide",
"total_sulfur_dioxide", "density", "pH", "sulphates", "alcohol", "quality" )
head(white)
head(white, 2)
summary(white)
ncol(white)
nrow(white)
# draw histograms
hist(fixed_acidity, breaks = 20) # normal with outliers
boxplot(fixed_acidity)
corrplot(corwhite) # linear correlation degree
colnames(white)
plot(quality~residual_sugar)
library(tidyverse)
white <- read.csv('data/winequality-white.csv', sep = ';')
names(white) <- c("fixed_acidity", "volatile_acidity", "citric_acid", "residual_sugar", "chlorides", "free_sulfur_dioxide",
"total_sulfur_dioxide", "density", "pH", "sulphates", "alcohol", "quality" )
data(USArrests)
head(USArrests)
lm(Murder~., USArrests)
arrest <- lm(Murder~., USArrests)
# 회귀직선이 유의미한지 알려면 B1 = B2 = B3 = ... = 0 이다를 귀무가설로 둔다
# 이 때 F분포는 MSR/MSE ~ F(k, n-k-1)이다
summary(arrest)
# 회귀직선이 유의미한지 알려면 B1 = B2 = B3 = ... = 0 이다를 귀무가설로 둔다
# 이 때 F분포는 MSR/MSE ~ F(k, n-k-1)이다
anova(arrest)
summary(arrest)
summaryArrest <- summary(arrest)
summaryArrest$residuals
sum(summaryArrest$residuals^2)
mse <- sum(summaryArrest$residuals^2)
sse <- sum(summaryArrest$residuals^2)
sse/(length(arrest)-2)
plot(arrest)
plot(arrest)
step(arrest, direction = "backward")
step(arrest, direction = "stepwise")
step(arrest, direction = "forward")
step(arrest, direction = "backward")
step(arrest, direction = "both")
# 회귀직선이 유의미한지 알려면 B1 = B2 = B3 = ... = 0 이다를 귀무가설로 둔다
# 이 때 F분포는 MSR/MSE ~ F(k, n-k-1)이다
anova(arrest)
# 회귀직선이 유의미한지 알려면 B1 = B2 = B3 = ... = 0 이다를 귀무가설로 둔다
# 이 때 F분포는 MSR/MSE ~ F(k, n-k-1)이다
anovar <- anova(arrest)
anovar$`Pr(>F)`
summary(anovar)
